##############################################################################
#
#  QuantLib-Risks Benchmarks
#
#  Compares different AD configurations for Swaption pricing:
#  - QL + XAD:       Original QuantLib-Risks-Cpp with XAD tape (baseline)
#  - QL + XAD-Forge: QuantLib-Risks-Cpp-Forge with Forge JIT backends
#
#  Jobs:
#  - Linux/Windows, QL + XAD:       True baseline (original repo, XAD tape)
#  - Linux/Windows, QL + XAD-Forge: Forge JIT (runs XAD tape + JIT + JIT-AVX)
#  - Decomposition:                 Detailed timing breakdown
#  - Compare:                       Statistical comparison XAD vs XAD-Forge
#
#  Type Overhead Measurement (pricing-only, no derivatives):
#  - Linux/Windows, double vs AReal (no diff): Compares plain double vs xad::AReal<double> on same hardware
#
#  Dependencies:
#  - QuantLib (lballabio/QuantLib)
#  - XAD (auto-differentiation/xad)
#  - QuantLib-Risks-Cpp (auto-differentiation/QuantLib-Risks-Cpp) [baseline]
#  - xad-forge (da-roth/xad-forge) [Forge jobs]
#  - Forge C API (da-roth/forge) [Forge jobs]
#
#  Copyright (C) 2025 Xcelerit Computing Limited
#  SPDX-License-Identifier: AGPL-3.0-or-later
#
##############################################################################

name: QL Benchmarks

on:
  push:
    paths:
      - 'test-suite/swaption_benchmark*.cpp'
      - 'test-suite/benchmark_main.cpp'
      - 'test-suite/benchmark_utils.hpp'
      - '.github/workflows/ql-benchmarks.yaml'
  pull_request:
    paths:
      - 'test-suite/swaption_benchmark*.cpp'
      - 'test-suite/benchmark_main.cpp'
      - 'test-suite/benchmark_utils.hpp'
      - '.github/workflows/ql-benchmarks.yaml'
  workflow_dispatch:
    inputs:
      ql_repo:
        description: 'QuantLib repository'
        required: false
        default: 'lballabio/QuantLib'
      ql_branch:
        description: 'QuantLib branch'
        required: false
        default: 'master'
      xad_repo:
        description: 'XAD repository'
        required: false
        default: 'auto-differentiation/xad'
      xad_branch:
        description: 'XAD branch'
        required: false
        default: 'main'
      qlrisks_repo:
        description: 'QuantLib-Risks-Cpp repository (for baseline)'
        required: false
        default: 'auto-differentiation/QuantLib-Risks-Cpp'
      qlrisks_branch:
        description: 'QuantLib-Risks-Cpp branch (for baseline)'
        required: false
        default: 'main'
      forge_repo:
        description: 'Forge repository'
        required: false
        default: 'da-roth/forge'
      forge_branch:
        description: 'Forge branch'
        required: false
        default: 'main'
      xad_forge_repo:
        description: 'xad-forge repository'
        required: false
        default: 'da-roth/xad-forge'
      xad_forge_branch:
        description: 'xad-forge branch'
        required: false
        default: 'main'

env:
  QL_REPO: ${{ github.event.inputs.ql_repo || 'lballabio/QuantLib' }}
  QL_BRANCH: ${{ github.event.inputs.ql_branch || 'master' }}
  XAD_REPO: ${{ github.event.inputs.xad_repo || 'auto-differentiation/xad' }}
  XAD_BRANCH: ${{ github.event.inputs.xad_branch || 'main' }}
  QLRISKS_REPO: ${{ github.event.inputs.qlrisks_repo || 'auto-differentiation/QuantLib-Risks-Cpp' }}
  QLRISKS_BRANCH: ${{ github.event.inputs.qlrisks_branch || 'main' }}
  FORGE_REPO: ${{ github.event.inputs.forge_repo || 'da-roth/forge' }}
  FORGE_BRANCH: ${{ github.event.inputs.forge_branch || 'main' }}
  XAD_FORGE_REPO: ${{ github.event.inputs.xad_forge_repo || 'da-roth/xad-forge' }}
  XAD_FORGE_BRANCH: ${{ github.event.inputs.xad_forge_branch || 'main' }}

jobs:
  ##############################################################################
  # Linux, QL + XAD (True Baseline)
  # Uses original QuantLib-Risks-Cpp with XAD tape - no Forge code
  ##############################################################################
  linux-xad:
    name: Linux, QL + XAD
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-ql-xad
          max-size: 650M

      - name: Patch benchmark into original QuantLib-Risks-Cpp
        run: |
          # Copy standalone benchmark files from Forge repo to original
          cp QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.hpp \
             QuantLib-Risks-Cpp/test-suite/

          # Add standalone benchmark target to CMakeLists.txt
          cat >> QuantLib-Risks-Cpp/test-suite/CMakeLists.txt << 'EOF'

          # Standalone benchmark (patched from QuantLib-Risks-Cpp-Forge)
          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib
        run: |
          cd QuantLib
          cmake -B build -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build
        run: |
          cd QuantLib/build
          cmake --build . --target QuantLib-Risks_benchmark_standalone

      - name: Run Benchmark
        run: |
          cd QuantLib/build
          ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone

  ##############################################################################
  # Linux, QL + XAD-Forge
  # Uses QuantLib-Risks-Cpp-Forge with Forge JIT backends
  # Runs all methods: XAD tape + JIT-Forge + JIT-ForgeAVX2
  ##############################################################################
  linux-xad-forge:
    name: Linux, QL + XAD-Forge
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-ql-xad-forge
          max-size: 650M

      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      - name: Configure QuantLib
        run: |
          cd QuantLib
          cmake -B build -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp-Forge" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_TEST_SUITE=OFF \
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON \
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build
        run: |
          cd QuantLib/build
          cmake --build .

      - name: Run Benchmark
        run: |
          cd QuantLib/build
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone

  ##############################################################################
  # Windows, QL + XAD (True Baseline)
  ##############################################################################
  windows-xad:
    name: Windows, QL + XAD
    runs-on: windows-2022

    env:
      VSVARSALL: C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat

    steps:
      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: choco install -y ninja

      - name: Setup Boost
        run: |
          $Url = "https://downloads.sourceforge.net/project/boost/boost-binaries/1.86.0/boost_1_86_0-msvc-14.3-64.exe"
          (New-Object System.Net.WebClient).DownloadFile($Url, "$RUNNER_TEMP\boost.exe")
          Start-Process -Wait -FilePath "$RUNNER_TEMP\boost.exe" "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=C:\local\boost"
          echo "BOOST_ROOT=C:\local\boost" >> $env:GITHUB_ENV

      - name: Patch benchmark into original QuantLib-Risks-Cpp
        shell: pwsh
        run: |
          # Copy standalone benchmark files from Forge repo to original
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.cpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.hpp" "QuantLib-Risks-Cpp/test-suite/"

          # Add standalone benchmark target to CMakeLists.txt
          $cmakeAddition = @"

          # Standalone benchmark (patched from QuantLib-Risks-Cpp-Forge)
          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              `${QL_THREAD_LIBRARIES})
          "@
          Add-Content -Path "QuantLib-Risks-Cpp/test-suite/CMakeLists.txt" -Value $cmakeAddition

      - name: Configure QuantLib
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=OFF ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%cd%\..\xad;%cd%\..\QuantLib-Risks-Cpp" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build
        shell: cmd
        run: |
          cd QuantLib\build
          call "%VSVARSALL%" amd64
          cmake --build . --target QuantLib-Risks_benchmark_standalone --config Release

      - name: Run Benchmark
        shell: cmd
        run: |
          cd QuantLib\build
          QuantLib-Risks-Cpp\test-suite\quantlib-risks-benchmark-standalone.exe

  ##############################################################################
  # Windows, QL + XAD-Forge
  ##############################################################################
  windows-xad-forge:
    name: Windows, QL + XAD-Forge
    runs-on: windows-2022

    env:
      VSVARSALL: C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat

    steps:
      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: choco install -y ninja

      - name: Setup Boost
        run: |
          $Url = "https://downloads.sourceforge.net/project/boost/boost-binaries/1.86.0/boost_1_86_0-msvc-14.3-64.exe"
          (New-Object System.Net.WebClient).DownloadFile($Url, "$RUNNER_TEMP\boost.exe")
          Start-Process -Wait -FilePath "$RUNNER_TEMP\boost.exe" "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=C:\local\boost"
          echo "BOOST_ROOT=C:\local\boost" >> $env:GITHUB_ENV

      - name: Build Forge C API
        shell: cmd
        run: |
          cd forge
          call "%VSVARSALL%" amd64
          cmake -B build -S api/c -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DFORGE_CAPI_BUILD_TESTS=OFF ^
            -DFORGE_CAPI_USE_STATIC_RUNTIME=ON ^
            -DCMAKE_INSTALL_PREFIX="%cd%\..\install"
          cmake --build build
          cmake --install build

      - name: Configure QuantLib
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=ON ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DCMAKE_PREFIX_PATH="%cd%\..\install" ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%cd%\..\xad;%cd%\..\xad-forge;%cd%\..\QuantLib-Risks-Cpp-Forge" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_ENABLE_FORGE=ON ^
            -DQLRISKS_USE_FORGE_CAPI=ON ^
            -DXAD_FORGE_USE_CAPI=ON ^
            -DQLRISKS_BUILD_TEST_SUITE=OFF ^
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON ^
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build
        shell: cmd
        run: |
          cd QuantLib\build
          call "%VSVARSALL%" amd64
          cmake --build . --config Release

      - name: Run Benchmark
        shell: cmd
        run: |
          cd QuantLib\build
          set PATH=%cd%\..\..\install\bin;%PATH%
          QuantLib-Risks-Cpp-Forge\test-suite\quantlib-risks-benchmark-standalone.exe

  ##############################################################################
  # Performance Decomposition - Detailed timing breakdown (XAD-Forge)
  ##############################################################################
  decomposition:
    name: Decomposition
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-decomposition
          max-size: 650M

      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      - name: Configure QuantLib
        run: |
          cd QuantLib
          cmake -B build -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp-Forge" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_TEST_SUITE=OFF \
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON \
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build
        run: |
          cd QuantLib/build
          cmake --build .

      - name: Run Performance Decomposition
        run: |
          cd QuantLib/build
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone --decomposition

  ##############################################################################
  # Compare XAD vs XAD-Forge - Statistical comparison
  ##############################################################################
  compare:
    name: Compare XAD vs XAD-Forge
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake bc

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-compare
          max-size: 650M

      # --- Build QL + XAD (baseline) ---
      - name: Patch benchmark into original QuantLib-Risks-Cpp
        run: |
          cp QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.hpp \
             QuantLib-Risks-Cpp/test-suite/

          cat >> QuantLib-Risks-Cpp/test-suite/CMakeLists.txt << 'EOF'

          # Standalone benchmark (patched from QuantLib-Risks-Cpp-Forge)
          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib (QL + XAD)
        run: |
          cd QuantLib
          cmake -B build-xad -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build (QL + XAD)
        run: |
          cd QuantLib/build-xad
          cmake --build . --target QuantLib-Risks_benchmark_standalone

      # --- Build QL + XAD-Forge ---
      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      - name: Configure QuantLib (QL + XAD-Forge)
        run: |
          cd QuantLib
          cmake -B build-forge -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp-Forge" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_TEST_SUITE=OFF \
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON \
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build (QL + XAD-Forge)
        run: |
          cd QuantLib/build-forge
          cmake --build .

      # --- Run benchmarks multiple times ---
      - name: Run Benchmark (QL + XAD)
        run: |
          set -e
          cd QuantLib/build-xad
          # warmup run
          ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone --quick
          rm -f benchmark_xad.log || true
          for i in $(seq 1 5) ; do \
            ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone | tee -a benchmark_xad.log ; \
          done

      - name: Run Benchmark (QL + XAD-Forge)
        run: |
          set -e
          cd QuantLib/build-forge
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          # warmup run
          ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone --quick
          rm -f benchmark_forge.log || true
          for i in $(seq 1 5) ; do \
            ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone | tee -a benchmark_forge.log ; \
          done

      - name: Compare Results
        id: compare
        run: |
          set -e

          echo "## Benchmark Comparison: QL + XAD vs QL + XAD-Forge" > benchmark_results.md
          echo "" >> benchmark_results.md
          echo "Comparing original QuantLib-Risks-Cpp (XAD tape) vs Forge repo (JIT + JIT-AVX)." >> benchmark_results.md
          echo "" >> benchmark_results.md
          echo "- Commit: \`${{ github.sha }}\`" >> benchmark_results.md
          echo "- Runs: 5 (after warmup)" >> benchmark_results.md
          echo "" >> benchmark_results.md

          echo "### QL + XAD (Baseline)" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md
          tail -80 QuantLib/build-xad/benchmark_xad.log >> benchmark_results.md || echo "No log available" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md
          echo "" >> benchmark_results.md

          echo "### QL + XAD-Forge" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md
          tail -80 QuantLib/build-forge/benchmark_forge.log >> benchmark_results.md || echo "No log available" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md

          cat benchmark_results.md

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-compare
          path: benchmark_results.md

  ##############################################################################
  # Linux, double vs AReal (no diff)
  # Compares plain double vs xad::AReal<double> on same hardware
  # This measures the overhead of the XAD type system in passive mode
  ##############################################################################
  linux-type-overhead:
    name: Linux, double vs AReal (no diff)
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-type-overhead
          max-size: 1G

      # =========================================================================
      # Build 1: QuantLib with plain double
      # =========================================================================
      - name: Create pricing-only benchmark for plain double
        run: |
          mkdir -p QuantLib/test-suite-double
          cat > QuantLib/test-suite-double/benchmark_double.cpp << 'EOFCPP'
          /*
           * Pricing-only benchmark using plain double (no XAD types)
           */
          #include <ql/quantlib.hpp>
          #include <chrono>
          #include <iostream>
          #include <iomanip>
          #include <vector>
          #include <numeric>
          #include <cmath>
          #include <algorithm>

          using namespace QuantLib;

          std::string getCpuInfo() {
          #ifdef __linux__
              FILE* fp = popen("grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2", "r");
              if (fp) {
                  char buf[256];
                  if (fgets(buf, sizeof(buf), fp)) {
                      pclose(fp);
                      std::string s(buf);
                      s.erase(0, s.find_first_not_of(" \t\n"));
                      s.erase(s.find_last_not_of(" \t\n") + 1);
                      return s;
                  }
                  pclose(fp);
              }
          #endif
              return "Unknown CPU";
          }

          double computeMean(const std::vector<double>& v) {
              if (v.empty()) return 0.0;
              return std::accumulate(v.begin(), v.end(), 0.0) / v.size();
          }

          double computeStddev(const std::vector<double>& v) {
              if (v.size() < 2) return 0.0;
              double mean = computeMean(v);
              double sq_sum = 0.0;
              for (auto x : v) sq_sum += (x - mean) * (x - mean);
              return std::sqrt(sq_sum / (v.size() - 1));
          }

          ext::shared_ptr<IborIndex> makeIndex(std::vector<Date> dates, const std::vector<Rate>& rates) {
              DayCounter dayCounter = Actual360();
              RelinkableHandle<YieldTermStructure> termStructure;
              ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));
              Date todaysDate = index->fixingCalendar().adjust(Date(4, September, 2005));
              Settings::instance().evaluationDate() = todaysDate;
              dates[0] = index->fixingCalendar().advance(todaysDate, index->fixingDays(), Days);
              termStructure.linkTo(ext::make_shared<ZeroCurve>(dates, rates, dayCounter));
              return index;
          }

          void runBenchmark(Size size, Size i_opt, Size j_opt, Size steps, int curveEndYears,
                            std::vector<std::pair<int, double>>& results) {
              using Clock = std::chrono::high_resolution_clock;
              using Duration = std::chrono::duration<double, std::milli>;

              Calendar calendar = TARGET();
              Date todaysDate(4, September, 2005);
              Settings::instance().evaluationDate() = todaysDate;
              Integer fixingDays = 2;
              Date settlementDate = calendar.adjust(calendar.advance(todaysDate, fixingDays, Days));
              DayCounter dayCounter = Actual360();

              std::vector<Rate> baseZeroRates = {0.035, 0.0575};
              std::vector<Date> baseDates = {settlementDate, settlementDate + curveEndYears * Years};
              auto baseIndex = makeIndex(baseDates, baseZeroRates);

              ext::shared_ptr<LiborForwardModelProcess> process(
                  new LiborForwardModelProcess(size, baseIndex));
              process->setCovarParam(ext::make_shared<LfmCovarianceProxy>(
                  ext::make_shared<LmLinearExponentialVolatilityModel>(
                      process->fixingTimes(), 0.291, 1.483, 0.116, 0.00001),
                  ext::make_shared<LmExponentialCorrelationModel>(size, 0.5)));

              std::vector<Time> fixingTimes = process->fixingTimes();
              TimeGrid grid(fixingTimes.begin(), fixingTimes.end(), steps);

              std::vector<Size> location;
              for (Size idx = 0; idx < fixingTimes.size(); ++idx)
                  location.push_back(std::find(grid.begin(), grid.end(), fixingTimes[idx]) - grid.begin());

              Size numFactors = process->factors();
              Size exerciseStep = location[i_opt];
              Size fullGridSteps = grid.size() - 1;
              Size fullGridRandoms = fullGridSteps * numFactors;

              BusinessDayConvention convention = baseIndex->businessDayConvention();
              Date fwdStart = settlementDate + Period(6 * i_opt, Months);
              Date fwdMaturity = fwdStart + Period(6 * j_opt, Months);
              Schedule schedule(fwdStart, fwdMaturity, baseIndex->tenor(), calendar,
                                convention, convention, DateGeneration::Forward, false);

              std::vector<double> accrualStart(size), accrualEnd(size);
              for (Size k = 0; k < size; ++k) {
                  accrualStart[k] = process->accrualStartTimes()[k];
                  accrualEnd[k] = process->accrualEndTimes()[k];
              }

              std::vector<int> pathCounts = {10, 100, 1000, 10000, 100000};
              Size maxPaths = 100000;

              std::cerr << "  Generating randoms..." << std::flush;
              typedef PseudoRandom::rsg_type rsg_type;
              rsg_type rsg = PseudoRandom::make_sequence_generator(fullGridRandoms, BigNatural(42));
              std::vector<std::vector<double>> allRandoms(maxPaths);
              for (Size n = 0; n < maxPaths; ++n) {
                  allRandoms[n].resize(fullGridRandoms);
                  const auto& seq = rsg.nextSequence();
                  for (Size m = 0; m < fullGridRandoms; ++m)
                      allRandoms[n][m] = seq.value[m];
              }
              std::cerr << " Done." << std::endl;

              ext::shared_ptr<VanillaSwap> fwdSwap(
                  new VanillaSwap(Swap::Receiver, 1.0, schedule, 0.05, dayCounter,
                                  schedule, baseIndex, 0.0, baseIndex->dayCounter()));
              fwdSwap->setPricingEngine(ext::make_shared<DiscountingSwapEngine>(
                  baseIndex->forwardingTermStructure()));
              double swapRate = fwdSwap->fairRate();
              Array initRates = process->initialValues();

              size_t warmupIters = 2, benchIters = 5;

              for (size_t tc = 0; tc < pathCounts.size(); ++tc) {
                  Size nrTrails = pathCounts[tc];
                  std::vector<double> times;

                  for (size_t iter = 0; iter < warmupIters + benchIters; ++iter) {
                      auto t_start = Clock::now();
                      double price = 0.0;
                      for (Size n = 0; n < nrTrails; ++n) {
                          Array asset(size);
                          for (Size k = 0; k < size; ++k) asset[k] = initRates[k];
                          Array assetAtExercise(size);
                          for (Size step = 1; step <= fullGridSteps; ++step) {
                              Size offset = (step - 1) * numFactors;
                              Array dw(numFactors);
                              for (Size f = 0; f < numFactors; ++f)
                                  dw[f] = allRandoms[n][offset + f];
                              asset = process->evolve(grid[step - 1], asset, grid.dt(step - 1), dw);
                              if (step == exerciseStep)
                                  for (Size k = 0; k < size; ++k) assetAtExercise[k] = asset[k];
                          }
                          Array dis(size);
                          double df = 1.0;
                          for (Size k = 0; k < size; ++k) {
                              df = df / (1.0 + assetAtExercise[k] * (accrualEnd[k] - accrualStart[k]));
                              dis[k] = df;
                          }
                          double npv = 0.0;
                          for (Size m = i_opt; m < i_opt + j_opt; ++m)
                              npv += (swapRate - assetAtExercise[m]) * (accrualEnd[m] - accrualStart[m]) * dis[m];
                          if (npv > 0.0) price += npv;
                      }
                      (void)price;
                      auto t_end = Clock::now();
                      if (iter >= warmupIters)
                          times.push_back(Duration(t_end - t_start).count());
                  }
                  results.push_back({pathCounts[tc], computeMean(times)});
              }
          }

          int main() {
              std::vector<std::pair<int, double>> smallResults, largeResults;

              std::cerr << "Running small swaption benchmark..." << std::endl;
              runBenchmark(10, 2, 2, 8, 6, smallResults);

              std::cerr << "Running large swaption benchmark..." << std::endl;
              runBenchmark(20, 10, 10, 20, 12, largeResults);

              // Output results in parseable format
              std::cout << "DOUBLE_SMALL:";
              for (auto& r : smallResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              std::cout << "DOUBLE_LARGE:";
              for (auto& r : largeResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              return 0;
          }
          EOFCPP

      - name: Add benchmark target to QuantLib CMakeLists
        run: |
          # Add standalone benchmark target to QuantLib's CMakeLists.txt
          cat >> QuantLib/CMakeLists.txt << 'EOF'

          # Plain double benchmark for type overhead comparison
          add_executable(benchmark_double test-suite-double/benchmark_double.cpp)
          target_link_libraries(benchmark_double PRIVATE ql_library ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib (plain double)
        run: |
          cd QuantLib
          cmake -B build-double -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF

      - name: Build QuantLib and benchmark (plain double)
        run: |
          cd QuantLib/build-double
          cmake --build . --target benchmark_double

      # =========================================================================
      # Build 2: QuantLib-Risks with xad::AReal<double>
      # =========================================================================
      - name: Patch benchmark into QuantLib-Risks-Cpp
        run: |
          cp QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp \
             QuantLib-Risks-Cpp/test-suite/

          cat >> QuantLib-Risks-Cpp/test-suite/CMakeLists.txt << 'EOF'

          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib (xad::AReal)
        run: |
          cd QuantLib
          cmake -B build-xad -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build QuantLib-Risks (xad::AReal)
        run: |
          cd QuantLib/build-xad
          cmake --build . --target QuantLib-Risks_benchmark_standalone

      # =========================================================================
      # Run both benchmarks and compare
      # =========================================================================
      - name: Run Benchmarks
        run: |
          set -e

          echo "===== Running plain double benchmark ====="
          cd QuantLib/build-double
          ./benchmark_double > double_results.txt 2>&1
          cat double_results.txt

          echo ""
          echo "===== Running xad::AReal benchmark ====="
          cd ../build-xad
          ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone --pricing-only > xad_results.txt 2>&1
          cat xad_results.txt

      - name: Generate Comparison Report
        run: |
          set -e
          cd QuantLib

          echo "================================================================================"
          echo "  TYPE OVERHEAD COMPARISON: double vs xad::AReal<double>"
          echo "================================================================================"
          echo ""
          echo "This compares pricing-only performance (no derivatives) to measure"
          echo "the overhead of using xad::AReal<double> instead of plain double."
          echo ""
          echo "Both benchmarks ran on the same hardware in this job."
          echo ""

          echo "===== Plain double (QuantLib) ====="
          grep -E "^DOUBLE_" build-double/double_results.txt || echo "Results parsing failed"
          echo ""

          echo "===== xad::AReal<double> (QuantLib-Risks) ====="
          cat build-xad/xad_results.txt
          echo ""

          echo "================================================================================"
          echo "  Analysis: Compare the timing values above."
          echo "  Overhead = (AReal time - double time) / double time * 100%"
          echo "================================================================================"

  ##############################################################################
  # Windows, double vs AReal (no diff)
  # Compares plain double vs xad::AReal<double> on same hardware
  # This measures the overhead of the XAD type system in passive mode
  ##############################################################################
  windows-type-overhead:
    name: Windows, double vs AReal (no diff)
    runs-on: windows-2022

    env:
      VSVARSALL: C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat

    steps:
      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: choco install -y ninja

      - name: Setup Boost
        run: |
          $Url = "https://downloads.sourceforge.net/project/boost/boost-binaries/1.86.0/boost_1_86_0-msvc-14.3-64.exe"
          (New-Object System.Net.WebClient).DownloadFile($Url, "$RUNNER_TEMP\boost.exe")
          Start-Process -Wait -FilePath "$RUNNER_TEMP\boost.exe" "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=C:\local\boost"
          echo "BOOST_ROOT=C:\local\boost" >> $env:GITHUB_ENV

      # =========================================================================
      # Build 1: QuantLib with plain double
      # =========================================================================
      - name: Create pricing-only benchmark for plain double
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "QuantLib/test-suite-double"
          @'
          /*
           * Pricing-only benchmark using plain double (no XAD types)
           */
          #include <ql/quantlib.hpp>
          #include <chrono>
          #include <iostream>
          #include <iomanip>
          #include <vector>
          #include <numeric>
          #include <cmath>
          #include <algorithm>

          using namespace QuantLib;

          double computeMean(const std::vector<double>& v) {
              if (v.empty()) return 0.0;
              return std::accumulate(v.begin(), v.end(), 0.0) / v.size();
          }

          double computeStddev(const std::vector<double>& v) {
              if (v.size() < 2) return 0.0;
              double mean = computeMean(v);
              double sq_sum = 0.0;
              for (auto x : v) sq_sum += (x - mean) * (x - mean);
              return std::sqrt(sq_sum / (v.size() - 1));
          }

          ext::shared_ptr<IborIndex> makeIndex(std::vector<Date> dates, const std::vector<Rate>& rates) {
              DayCounter dayCounter = Actual360();
              RelinkableHandle<YieldTermStructure> termStructure;
              ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));
              Date todaysDate = index->fixingCalendar().adjust(Date(4, September, 2005));
              Settings::instance().evaluationDate() = todaysDate;
              dates[0] = index->fixingCalendar().advance(todaysDate, index->fixingDays(), Days);
              termStructure.linkTo(ext::make_shared<ZeroCurve>(dates, rates, dayCounter));
              return index;
          }

          void runBenchmark(Size size, Size i_opt, Size j_opt, Size steps, int curveEndYears,
                            std::vector<std::pair<int, double>>& results) {
              using Clock = std::chrono::high_resolution_clock;
              using Duration = std::chrono::duration<double, std::milli>;

              Calendar calendar = TARGET();
              Date todaysDate(4, September, 2005);
              Settings::instance().evaluationDate() = todaysDate;
              Integer fixingDays = 2;
              Date settlementDate = calendar.adjust(calendar.advance(todaysDate, fixingDays, Days));
              DayCounter dayCounter = Actual360();

              std::vector<Rate> baseZeroRates = {0.035, 0.0575};
              std::vector<Date> baseDates = {settlementDate, settlementDate + curveEndYears * Years};
              auto baseIndex = makeIndex(baseDates, baseZeroRates);

              ext::shared_ptr<LiborForwardModelProcess> process(
                  new LiborForwardModelProcess(size, baseIndex));
              process->setCovarParam(ext::make_shared<LfmCovarianceProxy>(
                  ext::make_shared<LmLinearExponentialVolatilityModel>(
                      process->fixingTimes(), 0.291, 1.483, 0.116, 0.00001),
                  ext::make_shared<LmExponentialCorrelationModel>(size, 0.5)));

              std::vector<Time> fixingTimes = process->fixingTimes();
              TimeGrid grid(fixingTimes.begin(), fixingTimes.end(), steps);

              std::vector<Size> location;
              for (Size idx = 0; idx < fixingTimes.size(); ++idx)
                  location.push_back(std::find(grid.begin(), grid.end(), fixingTimes[idx]) - grid.begin());

              Size numFactors = process->factors();
              Size exerciseStep = location[i_opt];
              Size fullGridSteps = grid.size() - 1;
              Size fullGridRandoms = fullGridSteps * numFactors;

              BusinessDayConvention convention = baseIndex->businessDayConvention();
              Date fwdStart = settlementDate + Period(6 * i_opt, Months);
              Date fwdMaturity = fwdStart + Period(6 * j_opt, Months);
              Schedule schedule(fwdStart, fwdMaturity, baseIndex->tenor(), calendar,
                                convention, convention, DateGeneration::Forward, false);

              std::vector<double> accrualStart(size), accrualEnd(size);
              for (Size k = 0; k < size; ++k) {
                  accrualStart[k] = process->accrualStartTimes()[k];
                  accrualEnd[k] = process->accrualEndTimes()[k];
              }

              std::vector<int> pathCounts = {10, 100, 1000, 10000, 100000};
              Size maxPaths = 100000;

              std::cerr << "  Generating randoms..." << std::flush;
              typedef PseudoRandom::rsg_type rsg_type;
              rsg_type rsg = PseudoRandom::make_sequence_generator(fullGridRandoms, BigNatural(42));
              std::vector<std::vector<double>> allRandoms(maxPaths);
              for (Size n = 0; n < maxPaths; ++n) {
                  allRandoms[n].resize(fullGridRandoms);
                  const auto& seq = rsg.nextSequence();
                  for (Size m = 0; m < fullGridRandoms; ++m)
                      allRandoms[n][m] = seq.value[m];
              }
              std::cerr << " Done." << std::endl;

              ext::shared_ptr<VanillaSwap> fwdSwap(
                  new VanillaSwap(Swap::Receiver, 1.0, schedule, 0.05, dayCounter,
                                  schedule, baseIndex, 0.0, baseIndex->dayCounter()));
              fwdSwap->setPricingEngine(ext::make_shared<DiscountingSwapEngine>(
                  baseIndex->forwardingTermStructure()));
              double swapRate = fwdSwap->fairRate();
              Array initRates = process->initialValues();

              size_t warmupIters = 2, benchIters = 5;

              for (size_t tc = 0; tc < pathCounts.size(); ++tc) {
                  Size nrTrails = pathCounts[tc];
                  std::vector<double> times;

                  for (size_t iter = 0; iter < warmupIters + benchIters; ++iter) {
                      auto t_start = Clock::now();
                      double price = 0.0;
                      for (Size n = 0; n < nrTrails; ++n) {
                          Array asset(size);
                          for (Size k = 0; k < size; ++k) asset[k] = initRates[k];
                          Array assetAtExercise(size);
                          for (Size step = 1; step <= fullGridSteps; ++step) {
                              Size offset = (step - 1) * numFactors;
                              Array dw(numFactors);
                              for (Size f = 0; f < numFactors; ++f)
                                  dw[f] = allRandoms[n][offset + f];
                              asset = process->evolve(grid[step - 1], asset, grid.dt(step - 1), dw);
                              if (step == exerciseStep)
                                  for (Size k = 0; k < size; ++k) assetAtExercise[k] = asset[k];
                          }
                          Array dis(size);
                          double df = 1.0;
                          for (Size k = 0; k < size; ++k) {
                              df = df / (1.0 + assetAtExercise[k] * (accrualEnd[k] - accrualStart[k]));
                              dis[k] = df;
                          }
                          double npv = 0.0;
                          for (Size m = i_opt; m < i_opt + j_opt; ++m)
                              npv += (swapRate - assetAtExercise[m]) * (accrualEnd[m] - accrualStart[m]) * dis[m];
                          if (npv > 0.0) price += npv;
                      }
                      (void)price;
                      auto t_end = Clock::now();
                      if (iter >= warmupIters)
                          times.push_back(Duration(t_end - t_start).count());
                  }
                  results.push_back({pathCounts[tc], computeMean(times)});
              }
          }

          int main() {
              std::vector<std::pair<int, double>> smallResults, largeResults;

              std::cerr << "Running small swaption benchmark..." << std::endl;
              runBenchmark(10, 2, 2, 8, 6, smallResults);

              std::cerr << "Running large swaption benchmark..." << std::endl;
              runBenchmark(20, 10, 10, 20, 12, largeResults);

              std::cout << "DOUBLE_SMALL:";
              for (auto& r : smallResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              std::cout << "DOUBLE_LARGE:";
              for (auto& r : largeResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              return 0;
          }
          '@ | Out-File -FilePath "QuantLib/test-suite-double/benchmark_double.cpp" -Encoding utf8

      - name: Add benchmark target to QuantLib CMakeLists
        shell: pwsh
        run: |
          # Add standalone benchmark target to QuantLib's CMakeLists.txt
          $cmakeAddition = @"

          # Plain double benchmark for type overhead comparison
          add_executable(benchmark_double test-suite-double/benchmark_double.cpp)
          target_link_libraries(benchmark_double PRIVATE ql_library `${QL_THREAD_LIBRARIES})
          "@
          Add-Content -Path "QuantLib/CMakeLists.txt" -Value $cmakeAddition

      - name: Configure QuantLib (plain double)
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build-double -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF

      - name: Build QuantLib and benchmark (plain double)
        shell: cmd
        run: |
          cd QuantLib\build-double
          call "%VSVARSALL%" amd64
          cmake --build . --target benchmark_double --config Release

      # =========================================================================
      # Build 2: QuantLib-Risks with xad::AReal<double>
      # =========================================================================
      - name: Patch benchmark into QuantLib-Risks-Cpp
        shell: pwsh
        run: |
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp" "QuantLib-Risks-Cpp/test-suite/"

          $cmakeAddition = @"

          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              `${QL_THREAD_LIBRARIES})
          "@
          Add-Content -Path "QuantLib-Risks-Cpp/test-suite/CMakeLists.txt" -Value $cmakeAddition

      - name: Configure QuantLib (xad::AReal)
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build-xad -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=OFF ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%cd%\..\xad;%cd%\..\QuantLib-Risks-Cpp" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build QuantLib-Risks (xad::AReal)
        shell: cmd
        run: |
          cd QuantLib\build-xad
          call "%VSVARSALL%" amd64
          cmake --build . --target QuantLib-Risks_benchmark_standalone --config Release

      # =========================================================================
      # Run both benchmarks and compare
      # =========================================================================
      - name: Run Benchmarks
        shell: cmd
        run: |
          echo ===== Running plain double benchmark =====
          cd QuantLib\build-double
          benchmark_double.exe > double_results.txt 2>&1
          type double_results.txt

          echo.
          echo ===== Running xad::AReal benchmark =====
          cd ..\build-xad
          QuantLib-Risks-Cpp\test-suite\quantlib-risks-benchmark-standalone.exe --pricing-only > xad_results.txt 2>&1
          type xad_results.txt

      - name: Generate Comparison Report
        shell: pwsh
        run: |
          Write-Host "================================================================================"
          Write-Host "  TYPE OVERHEAD COMPARISON: double vs xad::AReal<double>"
          Write-Host "================================================================================"
          Write-Host ""
          Write-Host "This compares pricing-only performance (no derivatives) to measure"
          Write-Host "the overhead of using xad::AReal<double> instead of plain double."
          Write-Host ""
          Write-Host "Both benchmarks ran on the same hardware in this job."
          Write-Host ""

          Write-Host "===== Plain double (QuantLib) ====="
          Get-Content "QuantLib/build-double/double_results.txt" | Select-String "^DOUBLE_"
          Write-Host ""

          Write-Host "===== xad::AReal<double> (QuantLib-Risks) ====="
          Get-Content "QuantLib/build-xad/xad_results.txt"
          Write-Host ""

          Write-Host "================================================================================"
          Write-Host "  Analysis: Compare the timing values above."
          Write-Host "  Overhead = (AReal time - double time) / double time * 100%"
          Write-Host "================================================================================"
