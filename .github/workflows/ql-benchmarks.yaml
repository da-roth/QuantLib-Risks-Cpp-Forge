##############################################################################
#
#  QuantLib-Risks Benchmarks
#
#  Comprehensive benchmark comparing FD vs XAD vs Forge JIT
#
#  Structure:
#  - Two jobs: Linux and Windows
#  - Each job builds 3 versions on SAME hardware for fair comparison:
#    1. Plain double QuantLib (for FD)
#    2. XAD (JIT disabled) for XAD tape AAD
#    3. XAD + Forge (JIT enabled) for JIT/JIT-AVX AAD
#
#  Jobs:
#  - Linux, QL + XAD + Forge:   Full benchmark suite on Linux
#  - Windows, QL + XAD + Forge: Full benchmark suite on Windows
#
#  Dependencies:
#  - QuantLib (lballabio/QuantLib)
#  - XAD (auto-differentiation/xad)
#  - QuantLib-Risks-Cpp (this repo)
#  - xad-forge (da-roth/xad-forge) [Forge builds]
#  - Forge C API (da-roth/forge) [Forge builds]
#
#  Copyright (C) 2025 Xcelerit Computing Limited
#  SPDX-License-Identifier: AGPL-3.0-or-later
#
##############################################################################

name: QL Benchmarks

on:
  push:
    branches:
      - main
      - forge
  pull_request:
    branches:
      - main
      - forge
  workflow_dispatch:

env:
  QL_REPO: lballabio/QuantLib
  QL_BRANCH: master
  XAD_REPO: auto-differentiation/xad
  XAD_BRANCH: main
  FORGE_REPO: da-roth/forge
  FORGE_BRANCH: main
  XAD_FORGE_REPO: da-roth/xad-forge
  XAD_FORGE_BRANCH: main

jobs:
  ##############################################################################
  # Linux, QL + XAD + Forge
  # Comprehensive benchmark: FD (plain double) vs XAD vs Forge JIT
  ##############################################################################
  linux-benchmark:
    name: Linux, QL + XAD + Forge
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h
          echo "===== SIMD ====="
          cat /proc/cpuinfo | grep flags | head -1 | tr ' ' '\n' | grep -E "^(sse|avx)" | sort -u | tr '\n' ' '
          echo ""

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-benchmark
          max-size: 1G

      # =========================================================================
      # Build Forge C API (needed for JIT builds)
      # =========================================================================
      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      # =========================================================================
      # Benchmark 1: XAD + Forge (JIT enabled) - Run first (longest build)
      # =========================================================================
      - name: Configure QuantLib (XAD + Forge)
        run: |
          cd QuantLib
          cmake -B build-forge -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_BENCHMARK_AAD=ON

      - name: Build Forge benchmark (JIT on)
        run: |
          cd QuantLib/build-forge
          cmake --build . --target benchmark_aad

      - name: Run Forge Benchmark (JIT on)
        run: |
          echo "===== FORGE BENCHMARK (XAD + Forge JIT) ====="
          cd QuantLib/build-forge
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          ./QuantLib-Risks-Cpp/test-suite/benchmark-aad --all 2>&1 | tee forge_results.txt

      - name: Run XAD-Split vs JIT Diagnostic
        run: |
          echo "===== DIAGNOSTIC: XAD-Split vs JIT Derivative Comparison ====="
          cd QuantLib/build-forge
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          ./QuantLib-Risks-Cpp/test-suite/benchmark-aad --diagnose --diagnose-paths=100 2>&1 | tee diagnostic_results.txt

      # =========================================================================
      # Benchmark 2: Plain double QuantLib (for FD benchmark)
      # =========================================================================
      - name: Configure QuantLib (plain double)
        run: |
          cd QuantLib
          cmake -B build-double -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../QuantLib-Risks-Cpp" \
            -DQLRISKS_DISABLE_AAD=ON \
            -DQLRISKS_BUILD_BENCHMARK_FD=ON

      - name: Build FD benchmark (plain double)
        run: |
          cd QuantLib/build-double
          cmake --build . --target benchmark_fd

      - name: Run FD Benchmark (plain double)
        run: |
          echo "===== FD BENCHMARK (plain double QuantLib) ====="
          cd QuantLib/build-double
          ./QuantLib-Risks-Cpp/test-suite/benchmark-fd --all 2>&1 | tee fd_results.txt

      # =========================================================================
      # Benchmark 3: XAD (JIT disabled) for XAD tape AAD
      # =========================================================================
      - name: Configure QuantLib (XAD, JIT off)
        run: |
          cd QuantLib
          cmake -B build-xad -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_BUILD_BENCHMARK_AAD=ON

      - name: Build XAD benchmark (JIT off)
        run: |
          cd QuantLib/build-xad
          cmake --build . --target benchmark_aad

      - name: Run XAD Benchmark (JIT off)
        run: |
          echo "===== XAD BENCHMARK (XAD tape, JIT disabled) ====="
          cd QuantLib/build-xad
          ./QuantLib-Risks-Cpp/test-suite/benchmark-aad --all --xad-only 2>&1 | tee xad_results.txt

      # =========================================================================
      # Combine and display results
      # =========================================================================
      - name: Generate Combined Report
        run: |
          echo "================================================================================"
          echo "  COMBINED BENCHMARK RESULTS"
          echo "================================================================================"
          echo ""
          echo "All benchmarks ran on the same hardware for fair comparison."
          echo ""

          # Create a Python script to parse and format results
          cat > format_results.py << 'PYEOF'
          import sys
          import re
          from collections import defaultdict

          def parse_line(line):
              """Parse a line like 'METHOD_CONFIG:10=1.5,0.1,1[,fixed];100=5.2,0.2,1[,fixed]'"""
              match = re.match(r'^(\w+)_(\w+):(.+)$', line.strip())
              if not match:
                  return None
              method, config, data = match.groups()
              results = {}
              for item in data.split(';'):
                  if '=' in item:
                      paths, vals = item.split('=')
                      parts = vals.split(',')
                      mean, std, enabled = parts[0], parts[1], parts[2]
                      fixed = float(parts[3]) if len(parts) > 3 else 0.0
                      if enabled == '1' and float(mean) > 0:
                          results[int(paths)] = {'mean': float(mean), 'fixed': fixed}
              return method, config, results

          def parse_phases_line(line):
              """Parse JIT_PHASES_CONFIG:p1,p2,p3"""
              match = re.match(r'^JIT_PHASES_(\w+):(.+)$', line.strip())
              if not match:
                  return None
              config, data = match.groups()
              parts = data.split(',')
              if len(parts) >= 3:
                  return config, {
                      'phase1': float(parts[0]),
                      'phase2': float(parts[1]),
                      'phase3': float(parts[2])
                  }
              return None

          def format_num(n):
              """Format number with appropriate precision"""
              if n >= 1000:
                  return f"{n:.0f}"
              elif n >= 100:
                  return f"{n:.1f}"
              elif n >= 10:
                  return f"{n:.1f}"
              else:
                  return f"{n:.2f}"

          def format_paths(p):
              """Format path count: 100, 1K, 10K, 100K"""
              if p >= 1000:
                  return f"{p//1000}K"
              return str(p)

          def parse_validation_line(line):
              """Parse a line like 'VALIDATE_CONFIG_METHOD:pv;sens1,sens2,...'"""
              match = re.match(r'^VALIDATE_(\w+)_(\w+):(.+)$', line.strip())
              if not match:
                  return None
              config, method, data = match.groups()
              parts = data.split(';')
              if len(parts) != 2:
                  return None
              pv = float(parts[0])
              sens = [float(x) for x in parts[1].split(',') if x]
              return config, method, pv, sens

          def compare_sensitivities(sens1, sens2, tol_pct):
              """Compare two sensitivity vectors, return (matching_count, total, max_rel_diff)"""
              if len(sens1) != len(sens2):
                  return 0, max(len(sens1), len(sens2)), float('inf')
              matching = 0
              max_diff = 0.0
              for s1, s2 in zip(sens1, sens2):
                  if abs(s1) < 1e-12 and abs(s2) < 1e-12:
                      matching += 1
                      continue
                  base = max(abs(s1), abs(s2))
                  rel_diff = abs(s1 - s2) / base if base > 1e-12 else 0.0
                  max_diff = max(max_diff, rel_diff)
                  if rel_diff <= tol_pct / 100.0:
                      matching += 1
              return matching, len(sens1), max_diff * 100.0  # return as percentage

          # Read all result files
          data = defaultdict(lambda: defaultdict(dict))  # data[config][method][paths] = {mean, fixed}
          phases = {}  # phases[config] = {phase1, phase2, phase3}
          validation = defaultdict(dict)  # validation[config][method] = (pv, sens)

          for filepath in sys.argv[1:]:
              # Skip XADSPLIT from forge_results.txt (use xad_results.txt instead for fair comparison)
              is_forge_results = 'forge_results' in filepath
              try:
                  with open(filepath) as f:
                      for line in f:
                          result = parse_line(line)
                          if result:
                              method, config, results = result
                              # Use XADSPLIT from xad_results.txt, not forge_results.txt
                              if is_forge_results and method == 'XADSPLIT':
                                  continue
                              for paths, vals in results.items():
                                  data[config][method][paths] = vals
                          phase_result = parse_phases_line(line)
                          if phase_result:
                              config, phase_data = phase_result
                              phases[config] = phase_data
                          val_result = parse_validation_line(line)
                          if val_result:
                              config, method, pv, sens = val_result
                              validation[config][method] = (pv, sens)
              except FileNotFoundError:
                  pass

          # Print tables for each config
          configs = ['LITE', 'LITEEXT', 'PRODUCTION']
          config_names = {
              'LITE': 'Lite (1Y×1Y, 9 inputs)',
              'LITEEXT': 'Lite-Extended (5Y×5Y, 14 inputs)',
              'PRODUCTION': 'Production (5Y×5Y dual-curve, 45 inputs)'
          }

          # Column display names (JIT/XAD-Split columns have asterisk to indicate setup cost)
          method_display = {'FD': 'FD', 'XAD': 'XAD', 'XADSPLIT': 'XAD-Split*', 'JIT': 'JIT*', 'JITAVX': 'JIT-AVX2*'}
          col_width = 12  # Width for each numeric column

          for config in configs:
              if config not in data:
                  continue

              print(f"\n### {config_names.get(config, config)}\n")
              methods = data[config]
              all_paths = sorted(set(p for m in methods.values() for p in m.keys()))

              if not all_paths:
                  continue

              # Build header (no JIT-Setup column in main table)
              method_order = ['FD', 'XAD', 'XADSPLIT', 'JIT', 'JITAVX']
              present_methods = [m for m in method_order if m in methods]

              header = f"{'Paths':>6}"
              for m in present_methods:
                  header += f"{method_display[m]:>{col_width}}"
              print(header)

              # Separator line
              sep = "-" * len(header)
              print(sep)

              # Data rows
              for paths in all_paths:
                  row = f"{format_paths(paths):>6}"
                  for m in present_methods:
                      val = methods[m].get(paths)
                      if val:
                          row += f"{format_num(val['mean']):>{col_width}}"
                      else:
                          row += f"{'-':>{col_width}}"
                  print(row)

              # Print JIT phase breakdown table if available
              if config in phases:
                  p = phases[config]
                  total = p['phase1'] + p['phase2'] + p['phase3']
                  print(f"\n*JIT timing breakdown (one-time costs, independent of paths):\n")
                  print(f"  {'Phase':<35} {'Time (ms)':>10}")
                  print(f"  {'-'*45}")
                  print(f"  {'1. Curve bootstrap (XAD)':<35} {format_num(p['phase1']):>10}")
                  print(f"  {'2. Jacobian (XAD adjoints)':<35} {format_num(p['phase2']):>10}")
                  print(f"  {'3. JIT graph record + compile':<35} {format_num(p['phase3']):>10}")
                  print(f"  {'-'*45}")
                  print(f"  {'Total setup':<35} {format_num(total):>10}")

              # Print validation table if we have validation data for this config
              if config in validation and validation[config]:
                  val_methods = validation[config]
                  print(f"\nValidation (at 10K paths):\n")
                  print(f"  {'Method':<10} {'PV':>14} {'Sens':>6} {'vs FD':>8} {'FD MaxDiff':>12} {'vs XAD':>8} {'XAD MaxDiff':>12}")
                  print(f"  {'-'*72}")

                  method_order = ['FD', 'XAD', 'XADSPLIT', 'JIT', 'JITAVX']
                  fd_sens = val_methods.get('FD', (None, []))[1]
                  xad_sens = val_methods.get('XAD', (None, []))[1]

                  for m in method_order:
                      if m not in val_methods:
                          continue
                      pv, sens = val_methods[m]

                      # Compare vs FD (1% tolerance)
                      if m == 'FD':
                          vs_fd = '-'
                          fd_maxdiff = '-'
                      elif fd_sens:
                          match, total, maxd = compare_sensitivities(sens, fd_sens, 1.0)
                          vs_fd = f"{match}/{total}"
                          fd_maxdiff = f"{maxd:.2f}%"
                      else:
                          vs_fd = '-'
                          fd_maxdiff = '-'

                      # Compare vs XAD (0.01% tolerance)
                      if m in ('FD', 'XAD'):
                          vs_xad = '-'
                          xad_maxdiff = '-'
                      elif xad_sens:
                          match, total, maxd = compare_sensitivities(sens, xad_sens, 0.01)
                          vs_xad = f"{match}/{total}"
                          xad_maxdiff = f"{maxd:.4f}%"
                      else:
                          vs_xad = '-'
                          xad_maxdiff = '-'

                      print(f"  {m:<10} {pv:>14.6f} {len(sens):>6} {vs_fd:>8} {fd_maxdiff:>12} {vs_xad:>8} {xad_maxdiff:>12}")

          # Determine which methods are present across all configs
          all_methods = set()
          for config in configs:
              if config in data:
                  all_methods.update(data[config].keys())

          print("\nAll times in milliseconds (ms).")
          has_jit = 'JIT' in all_methods or 'JITAVX' in all_methods
          has_xadsplit = 'XADSPLIT' in all_methods
          if has_jit and has_xadsplit:
              print("*JIT and JIT-AVX2 include one-time setup cost (see breakdown above). XAD-Split avoids recording")
              print(" all MC paths on a single tape by computing the Jacobian separately and re-recording a small")
              print(" tape per path - no JIT compilation involved.")
          elif has_xadsplit:
              print("*XAD-Split avoids recording all MC paths on a single tape by computing the Jacobian separately")
              print(" and re-recording a small tape per path.")
          elif has_jit:
              print("*JIT and JIT-AVX2 include one-time setup cost (see breakdown above).")
          PYEOF

          python3 format_results.py \
            QuantLib/build-double/fd_results.txt \
            QuantLib/build-xad/xad_results.txt \
            QuantLib/build-forge/forge_results.txt

          echo ""
          echo "================================================================================"
          echo ""
          echo "Raw data (for parsing):"
          echo ""
          grep -E "^(FD_|VALIDATE_)" QuantLib/build-double/fd_results.txt 2>/dev/null || true
          grep -E "^(XAD_|XADSPLIT_|VALIDATE_)" QuantLib/build-xad/xad_results.txt 2>/dev/null || true
          grep -E "^(JIT_|JITAVX_|JIT_PHASES_|VALIDATE_)" QuantLib/build-forge/forge_results.txt 2>/dev/null || true

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: linux-benchmark-results
          path: |
            QuantLib/build-double/fd_results.txt
            QuantLib/build-xad/xad_results.txt
            QuantLib/build-forge/forge_results.txt

  ##############################################################################
  # Windows, QL + XAD + Forge
  # Comprehensive benchmark: FD (plain double) vs XAD vs Forge JIT
  ##############################################################################
  windows-benchmark:
    name: Windows, QL + XAD + Forge
    runs-on: windows-2022

    env:
      VSVARSALL: C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat

    steps:
      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp

      - name: Setup
        run: choco install -y ninja

      - name: Setup Boost
        run: |
          $Url = "https://downloads.sourceforge.net/project/boost/boost-binaries/1.86.0/boost_1_86_0-msvc-14.3-64.exe"
          (New-Object System.Net.WebClient).DownloadFile($Url, "$RUNNER_TEMP\boost.exe")
          Start-Process -Wait -FilePath "$RUNNER_TEMP\boost.exe" "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=C:\local\boost"
          echo "BOOST_ROOT=C:\local\boost" >> $env:GITHUB_ENV

      # =========================================================================
      # Build Forge C API
      # =========================================================================
      - name: Build Forge C API
        shell: cmd
        run: |
          call "%VSVARSALL%" x64
          cd forge
          cmake -B build -S api/c -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DFORGE_CAPI_BUILD_TESTS=OFF ^
            -DFORGE_CAPI_USE_STATIC_RUNTIME=ON ^
            -DCMAKE_INSTALL_PREFIX=%CD%\..\install
          cmake --build build
          cmake --install build

      # =========================================================================
      # Benchmark 1: XAD + Forge (JIT enabled) - Run first (longest build)
      # =========================================================================
      - name: Configure QuantLib (XAD + Forge)
        shell: cmd
        run: |
          call "%VSVARSALL%" x64
          cd QuantLib
          cmake -B build-forge -G Ninja ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=ON ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DCMAKE_PREFIX_PATH=%CD%\..\install ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%CD%\..\xad;%CD%\..\xad-forge;%CD%\..\QuantLib-Risks-Cpp" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_ENABLE_FORGE=ON ^
            -DQLRISKS_USE_FORGE_CAPI=ON ^
            -DXAD_FORGE_USE_CAPI=ON ^
            -DQLRISKS_BUILD_BENCHMARK_AAD=ON

      - name: Build Forge benchmark (JIT on)
        shell: cmd
        run: |
          call "%VSVARSALL%" x64
          cd QuantLib\build-forge
          cmake --build . --target benchmark_aad

      - name: Run Forge Benchmark (JIT on)
        shell: cmd
        run: |
          echo ===== FORGE BENCHMARK (XAD + Forge JIT) =====
          cd QuantLib\build-forge
          set PATH=%CD%\..\..\install\bin;%PATH%
          QuantLib-Risks-Cpp\test-suite\benchmark-aad.exe --all > forge_results.txt 2>&1
          type forge_results.txt

      - name: Run XAD-Split vs JIT Diagnostic
        shell: cmd
        run: |
          echo ===== DIAGNOSTIC: XAD-Split vs JIT Derivative Comparison =====
          cd QuantLib\build-forge
          set PATH=%CD%\..\..\install\bin;%PATH%
          QuantLib-Risks-Cpp\test-suite\benchmark-aad.exe --diagnose --diagnose-paths=100 > diagnostic_results.txt 2>&1
          type diagnostic_results.txt

      # =========================================================================
      # Benchmark 2: Plain double QuantLib (for FD benchmark)
      # =========================================================================
      - name: Configure QuantLib (plain double)
        shell: cmd
        run: |
          call "%VSVARSALL%" x64
          cd QuantLib
          cmake -B build-double -G Ninja ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%CD%\..\QuantLib-Risks-Cpp" ^
            -DQLRISKS_DISABLE_AAD=ON ^
            -DQLRISKS_BUILD_BENCHMARK_FD=ON

      - name: Build FD benchmark (plain double)
        shell: cmd
        run: |
          call "%VSVARSALL%" x64
          cd QuantLib\build-double
          cmake --build . --target benchmark_fd

      - name: Run FD Benchmark (plain double)
        shell: cmd
        run: |
          echo ===== FD BENCHMARK (plain double QuantLib) =====
          cd QuantLib\build-double
          QuantLib-Risks-Cpp\test-suite\benchmark-fd.exe --all > fd_results.txt 2>&1
          type fd_results.txt

      # =========================================================================
      # Benchmark 3: XAD (JIT disabled) for XAD tape AAD
      # =========================================================================
      - name: Configure QuantLib (XAD, JIT off)
        shell: cmd
        run: |
          call "%VSVARSALL%" x64
          cd QuantLib
          cmake -B build-xad -G Ninja ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=OFF ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%CD%\..\xad;%CD%\..\QuantLib-Risks-Cpp" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_BUILD_BENCHMARK_AAD=ON

      - name: Build XAD benchmark (JIT off)
        shell: cmd
        run: |
          call "%VSVARSALL%" x64
          cd QuantLib\build-xad
          cmake --build . --target benchmark_aad

      - name: Run XAD Benchmark (JIT off)
        shell: cmd
        run: |
          echo ===== XAD BENCHMARK (XAD tape, JIT disabled) =====
          cd QuantLib\build-xad
          QuantLib-Risks-Cpp\test-suite\benchmark-aad.exe --all --xad-only > xad_results.txt 2>&1
          type xad_results.txt

      # =========================================================================
      # Combine and display results
      # =========================================================================
      - name: Generate Combined Report
        shell: pwsh
        run: |
          Write-Host "================================================================================"
          Write-Host "  COMBINED BENCHMARK RESULTS (Windows)"
          Write-Host "================================================================================"
          Write-Host ""
          Write-Host "All benchmarks ran on the same hardware for fair comparison."
          Write-Host ""

          $script = @'
          import sys
          import re
          from collections import defaultdict

          def parse_line(line):
              match = re.match(r'^(\w+)_(\w+):(.+)$', line.strip())
              if not match:
                  return None
              method, config, data = match.groups()
              results = {}
              for item in data.split(';'):
                  if '=' in item:
                      paths, vals = item.split('=')
                      parts = vals.split(',')
                      mean, std, enabled = parts[0], parts[1], parts[2]
                      fixed = float(parts[3]) if len(parts) > 3 else 0.0
                      if enabled == '1' and float(mean) > 0:
                          results[int(paths)] = {'mean': float(mean), 'fixed': fixed}
              return method, config, results

          def parse_phases_line(line):
              match = re.match(r'^JIT_PHASES_(\w+):(.+)$', line.strip())
              if not match:
                  return None
              config, data = match.groups()
              parts = data.split(',')
              if len(parts) >= 3:
                  return config, {'phase1': float(parts[0]), 'phase2': float(parts[1]), 'phase3': float(parts[2])}
              return None

          def format_num(n):
              if n >= 1000: return f"{n:.0f}"
              elif n >= 100: return f"{n:.1f}"
              elif n >= 10: return f"{n:.1f}"
              else: return f"{n:.2f}"

          def format_paths(p):
              if p >= 1000: return f"{p//1000}K"
              return str(p)

          def parse_validation_line(line):
              match = re.match(r'^VALIDATE_(\w+)_(\w+):(.+)$', line.strip())
              if not match:
                  return None
              config, method, data = match.groups()
              parts = data.split(';')
              if len(parts) != 2:
                  return None
              pv = float(parts[0])
              sens = [float(x) for x in parts[1].split(',') if x]
              return config, method, pv, sens

          def compare_sensitivities(sens1, sens2, tol_pct):
              if len(sens1) != len(sens2):
                  return 0, max(len(sens1), len(sens2)), float('inf')
              matching = 0
              max_diff = 0.0
              for s1, s2 in zip(sens1, sens2):
                  if abs(s1) < 1e-12 and abs(s2) < 1e-12:
                      matching += 1
                      continue
                  base = max(abs(s1), abs(s2))
                  rel_diff = abs(s1 - s2) / base if base > 1e-12 else 0.0
                  max_diff = max(max_diff, rel_diff)
                  if rel_diff <= tol_pct / 100.0:
                      matching += 1
              return matching, len(sens1), max_diff * 100.0

          data = defaultdict(lambda: defaultdict(dict))
          phases = {}
          validation = defaultdict(dict)
          for filepath in sys.argv[1:]:
              # Skip XADSPLIT from forge_results.txt (use xad_results.txt instead)
              is_forge_results = 'forge_results' in filepath
              try:
                  with open(filepath) as f:
                      for line in f:
                          result = parse_line(line)
                          if result:
                              method, config, results = result
                              if is_forge_results and method == 'XADSPLIT':
                                  continue
                              for paths, vals in results.items():
                                  data[config][method][paths] = vals
                          phase_result = parse_phases_line(line)
                          if phase_result:
                              config, phase_data = phase_result
                              phases[config] = phase_data
                          val_result = parse_validation_line(line)
                          if val_result:
                              config, method, pv, sens = val_result
                              validation[config][method] = (pv, sens)
              except: pass

          configs = ['LITE', 'LITEEXT', 'PRODUCTION']
          names = {'LITE': 'Lite (1Y×1Y, 9 inputs)', 'LITEEXT': 'Lite-Extended (5Y×5Y, 14 inputs)', 'PRODUCTION': 'Production (5Y×5Y dual-curve, 45 inputs)'}
          method_display = {'FD': 'FD', 'XAD': 'XAD', 'XADSPLIT': 'XAD-Split*', 'JIT': 'JIT*', 'JITAVX': 'JIT-AVX2*'}
          col_width = 12

          for config in configs:
              if config not in data: continue
              print(f"\n### {names.get(config, config)}\n")
              methods = data[config]
              all_paths = sorted(set(p for m in methods.values() for p in m.keys()))
              if not all_paths: continue

              method_order = ['FD', 'XAD', 'XADSPLIT', 'JIT', 'JITAVX']
              present = [m for m in method_order if m in methods]

              header = f"{'Paths':>6}"
              for m in present:
                  header += f"{method_display[m]:>{col_width}}"
              print(header)
              print("-" * len(header))

              for paths in all_paths:
                  row = f"{format_paths(paths):>6}"
                  for m in present:
                      v = methods[m].get(paths)
                      if v:
                          row += f"{format_num(v['mean']):>{col_width}}"
                      else:
                          row += f"{'-':>{col_width}}"
                  print(row)

              if config in phases:
                  p = phases[config]
                  total = p['phase1'] + p['phase2'] + p['phase3']
                  print(f"\n*JIT timing breakdown (one-time costs, independent of paths):\n")
                  print(f"  {'Phase':<35} {'Time (ms)':>10}")
                  print(f"  {'-'*45}")
                  print(f"  {'1. Curve bootstrap (XAD)':<35} {format_num(p['phase1']):>10}")
                  print(f"  {'2. Jacobian (XAD adjoints)':<35} {format_num(p['phase2']):>10}")
                  print(f"  {'3. JIT graph record + compile':<35} {format_num(p['phase3']):>10}")
                  print(f"  {'-'*45}")
                  print(f"  {'Total setup':<35} {format_num(total):>10}")

              if config in validation and validation[config]:
                  val_methods = validation[config]
                  print(f"\nValidation (at 10K paths):\n")
                  print(f"  {'Method':<10} {'PV':>14} {'Sens':>6} {'vs FD':>8} {'FD MaxDiff':>12} {'vs XAD':>8} {'XAD MaxDiff':>12}")
                  print(f"  {'-'*72}")
                  method_order = ['FD', 'XAD', 'XADSPLIT', 'JIT', 'JITAVX']
                  fd_sens = val_methods.get('FD', (None, []))[1]
                  xad_sens = val_methods.get('XAD', (None, []))[1]
                  for m in method_order:
                      if m not in val_methods: continue
                      pv, sens = val_methods[m]
                      if m == 'FD':
                          vs_fd, fd_maxdiff = '-', '-'
                      elif fd_sens:
                          match, total, maxd = compare_sensitivities(sens, fd_sens, 1.0)
                          vs_fd, fd_maxdiff = f"{match}/{total}", f"{maxd:.2f}%"
                      else:
                          vs_fd, fd_maxdiff = '-', '-'
                      if m in ('FD', 'XAD'):
                          vs_xad, xad_maxdiff = '-', '-'
                      elif xad_sens:
                          match, total, maxd = compare_sensitivities(sens, xad_sens, 0.01)
                          vs_xad, xad_maxdiff = f"{match}/{total}", f"{maxd:.4f}%"
                      else:
                          vs_xad, xad_maxdiff = '-', '-'
                      print(f"  {m:<10} {pv:>14.6f} {len(sens):>6} {vs_fd:>8} {fd_maxdiff:>12} {vs_xad:>8} {xad_maxdiff:>12}")

          # Determine which methods are present across all configs
          all_methods = set()
          for config in configs:
              if config in data:
                  all_methods.update(data[config].keys())

          print("\nAll times in milliseconds (ms).")
          has_jit = 'JIT' in all_methods or 'JITAVX' in all_methods
          has_xadsplit = 'XADSPLIT' in all_methods
          if has_jit and has_xadsplit:
              print("*JIT and JIT-AVX2 include one-time setup cost (see breakdown above). XAD-Split avoids recording")
              print(" all MC paths on a single tape by computing the Jacobian separately and re-recording a small")
              print(" tape per path - no JIT compilation involved.")
          elif has_xadsplit:
              print("*XAD-Split avoids recording all MC paths on a single tape by computing the Jacobian separately")
              print(" and re-recording a small tape per path.")
          elif has_jit:
              print("*JIT and JIT-AVX2 include one-time setup cost (see breakdown above).")
          '@

          $script | Out-File -FilePath format_results.py -Encoding utf8
          python format_results.py `
            QuantLib/build-double/fd_results.txt `
            QuantLib/build-xad/xad_results.txt `
            QuantLib/build-forge/forge_results.txt

          Write-Host ""
          Write-Host "================================================================================"

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: windows-benchmark-results
          path: |
            QuantLib/build-double/fd_results.txt
            QuantLib/build-xad/xad_results.txt
            QuantLib/build-forge/forge_results.txt
