##############################################################################
#
#  QuantLib-Risks Benchmarks
#
#  Compares different AD configurations for Swaption pricing:
#  - QL + XAD:       QuantLib-Risks-Cpp with XAD tape (baseline)
#  - QL + XAD-Forge: QuantLib-Risks-Cpp with Forge JIT backends
#
#  Jobs:
#  - Linux/Windows, QL + XAD:       True baseline (original repo, XAD tape)
#  - Linux/Windows, QL + XAD-Forge: Forge JIT (runs XAD tape + JIT + JIT-AVX)
#  - Decomposition:                 Detailed timing breakdown
#  - Compare:                       Statistical comparison XAD vs XAD-Forge
#
#  Type Overhead Measurement (pricing-only, no derivatives):
#  - Linux/Windows, double vs AReal (no diff): Compares plain double vs xad::AReal<double> on same hardware
#
#  Dependencies:
#  - QuantLib (lballabio/QuantLib)
#  - XAD (auto-differentiation/xad)
#  - QuantLib-Risks-Cpp (auto-differentiation/QuantLib-Risks-Cpp) [baseline]
#  - xad-forge (da-roth/xad-forge) [Forge jobs]
#  - Forge C API (da-roth/forge) [Forge jobs]
#
#  Copyright (C) 2025 Xcelerit Computing Limited
#  SPDX-License-Identifier: AGPL-3.0-or-later
#
##############################################################################

name: QL Benchmarks

on:
  push:
    paths:
      - 'test-suite/swaption_benchmark*.cpp'
      - 'test-suite/benchmark_main.cpp'
      - 'test-suite/benchmark_utils.hpp'
      - '.github/workflows/ql-benchmarks.yaml'
  pull_request:
    paths:
      - 'test-suite/swaption_benchmark*.cpp'
      - 'test-suite/benchmark_main.cpp'
      - 'test-suite/benchmark_utils.hpp'
      - '.github/workflows/ql-benchmarks.yaml'
  workflow_dispatch:
    inputs:
      ql_repo:
        description: 'QuantLib repository'
        required: false
        default: 'lballabio/QuantLib'
      ql_branch:
        description: 'QuantLib branch'
        required: false
        default: 'master'
      xad_repo:
        description: 'XAD repository'
        required: false
        default: 'auto-differentiation/xad'
      xad_branch:
        description: 'XAD branch'
        required: false
        default: 'main'
      qlrisks_repo:
        description: 'QuantLib-Risks-Cpp repository (for baseline)'
        required: false
        default: 'auto-differentiation/QuantLib-Risks-Cpp'
      qlrisks_branch:
        description: 'QuantLib-Risks-Cpp branch (for baseline)'
        required: false
        default: 'main'
      forge_repo:
        description: 'Forge repository'
        required: false
        default: 'da-roth/forge'
      forge_branch:
        description: 'Forge branch'
        required: false
        default: 'main'
      xad_forge_repo:
        description: 'xad-forge repository'
        required: false
        default: 'da-roth/xad-forge'
      xad_forge_branch:
        description: 'xad-forge branch'
        required: false
        default: 'main'

env:
  QL_REPO: ${{ github.event.inputs.ql_repo || 'lballabio/QuantLib' }}
  QL_BRANCH: ${{ github.event.inputs.ql_branch || 'master' }}
  XAD_REPO: ${{ github.event.inputs.xad_repo || 'auto-differentiation/xad' }}
  XAD_BRANCH: ${{ github.event.inputs.xad_branch || 'main' }}
  QLRISKS_REPO: ${{ github.event.inputs.qlrisks_repo || 'auto-differentiation/QuantLib-Risks-Cpp' }}
  QLRISKS_BRANCH: ${{ github.event.inputs.qlrisks_branch || 'main' }}
  FORGE_REPO: ${{ github.event.inputs.forge_repo || 'da-roth/forge' }}
  FORGE_BRANCH: ${{ github.event.inputs.forge_branch || 'main' }}
  XAD_FORGE_REPO: ${{ github.event.inputs.xad_forge_repo || 'da-roth/xad-forge' }}
  XAD_FORGE_BRANCH: ${{ github.event.inputs.xad_forge_branch || 'main' }}

jobs:
  ##############################################################################
  # Linux, QL + XAD (True Baseline)
  # Uses original QuantLib-Risks-Cpp with XAD tape - no Forge code
  ##############################################################################
  linux-xad:
    name: Linux, QL + XAD
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-ql-xad
          max-size: 650M

      - name: Patch benchmark into original QuantLib-Risks-Cpp
        run: |
          # Copy standalone benchmark files from Forge repo to original
          cp QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.hpp \
             QuantLib-Risks-Cpp/test-suite/

          # Add standalone benchmark target to CMakeLists.txt
          cat >> QuantLib-Risks-Cpp/test-suite/CMakeLists.txt << 'EOF'

          # Standalone benchmark (patched from QuantLib-Risks-Cpp-Forge)
          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib
        run: |
          cd QuantLib
          cmake -B build -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build
        run: |
          cd QuantLib/build
          cmake --build . --target QuantLib-Risks_benchmark_standalone

      - name: Run Benchmark
        run: |
          cd QuantLib/build
          ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone

  ##############################################################################
  # Linux, QL + XAD-Forge
  # Uses QuantLib-Risks-Cpp with Forge JIT backends
  # Runs all methods: XAD tape + JIT-Forge + JIT-ForgeAVX2
  ##############################################################################
  linux-xad-forge:
    name: Linux, QL + XAD-Forge
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-ql-xad-forge
          max-size: 650M

      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      - name: Configure QuantLib
        run: |
          cd QuantLib
          cmake -B build -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp-Forge" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_TEST_SUITE=OFF \
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON \
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build
        run: |
          cd QuantLib/build
          cmake --build .

      - name: Run Benchmark
        run: |
          cd QuantLib/build
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone

  ##############################################################################
  # Windows, QL + XAD (True Baseline)
  ##############################################################################
  windows-xad:
    name: Windows, QL + XAD
    runs-on: windows-2022

    env:
      VSVARSALL: C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat

    steps:
      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: choco install -y ninja

      - name: Setup Boost
        run: |
          $Url = "https://downloads.sourceforge.net/project/boost/boost-binaries/1.86.0/boost_1_86_0-msvc-14.3-64.exe"
          (New-Object System.Net.WebClient).DownloadFile($Url, "$RUNNER_TEMP\boost.exe")
          Start-Process -Wait -FilePath "$RUNNER_TEMP\boost.exe" "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=C:\local\boost"
          echo "BOOST_ROOT=C:\local\boost" >> $env:GITHUB_ENV

      - name: Patch benchmark into original QuantLib-Risks-Cpp
        shell: pwsh
        run: |
          # Copy standalone benchmark files from Forge repo to original
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.cpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.hpp" "QuantLib-Risks-Cpp/test-suite/"

          # Add standalone benchmark target to CMakeLists.txt
          $cmakeAddition = @"

          # Standalone benchmark (patched from QuantLib-Risks-Cpp-Forge)
          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              `${QL_THREAD_LIBRARIES})
          "@
          Add-Content -Path "QuantLib-Risks-Cpp/test-suite/CMakeLists.txt" -Value $cmakeAddition

      - name: Configure QuantLib
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=OFF ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%cd%\..\xad;%cd%\..\QuantLib-Risks-Cpp" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build
        shell: cmd
        run: |
          cd QuantLib\build
          call "%VSVARSALL%" amd64
          cmake --build . --target QuantLib-Risks_benchmark_standalone --config Release

      - name: Run Benchmark
        shell: cmd
        run: |
          cd QuantLib\build
          QuantLib-Risks-Cpp\test-suite\quantlib-risks-benchmark-standalone.exe

  ##############################################################################
  # Windows, QL + XAD-Forge
  ##############################################################################
  windows-xad-forge:
    name: Windows, QL + XAD-Forge
    runs-on: windows-2022

    env:
      VSVARSALL: C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat

    steps:
      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: choco install -y ninja

      - name: Setup Boost
        run: |
          $Url = "https://downloads.sourceforge.net/project/boost/boost-binaries/1.86.0/boost_1_86_0-msvc-14.3-64.exe"
          (New-Object System.Net.WebClient).DownloadFile($Url, "$RUNNER_TEMP\boost.exe")
          Start-Process -Wait -FilePath "$RUNNER_TEMP\boost.exe" "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=C:\local\boost"
          echo "BOOST_ROOT=C:\local\boost" >> $env:GITHUB_ENV

      - name: Build Forge C API
        shell: cmd
        run: |
          cd forge
          call "%VSVARSALL%" amd64
          cmake -B build -S api/c -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DFORGE_CAPI_BUILD_TESTS=OFF ^
            -DFORGE_CAPI_USE_STATIC_RUNTIME=ON ^
            -DCMAKE_INSTALL_PREFIX="%cd%\..\install"
          cmake --build build
          cmake --install build

      - name: Configure QuantLib
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=ON ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DCMAKE_PREFIX_PATH="%cd%\..\install" ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%cd%\..\xad;%cd%\..\xad-forge;%cd%\..\QuantLib-Risks-Cpp-Forge" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_ENABLE_FORGE=ON ^
            -DQLRISKS_USE_FORGE_CAPI=ON ^
            -DXAD_FORGE_USE_CAPI=ON ^
            -DQLRISKS_BUILD_TEST_SUITE=OFF ^
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON ^
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build
        shell: cmd
        run: |
          cd QuantLib\build
          call "%VSVARSALL%" amd64
          cmake --build . --config Release

      - name: Run Benchmark
        shell: cmd
        run: |
          cd QuantLib\build
          set PATH=%cd%\..\..\install\bin;%PATH%
          QuantLib-Risks-Cpp-Forge\test-suite\quantlib-risks-benchmark-standalone.exe

  ##############################################################################
  # Performance Decomposition - Detailed timing breakdown (XAD-Forge)
  ##############################################################################
  decomposition:
    name: Decomposition
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-decomposition
          max-size: 650M

      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      - name: Configure QuantLib
        run: |
          cd QuantLib
          cmake -B build -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp-Forge" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_TEST_SUITE=OFF \
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON \
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build
        run: |
          cd QuantLib/build
          cmake --build .

      - name: Run Performance Decomposition
        run: |
          cd QuantLib/build
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone --decomposition

  ##############################################################################
  # Compare XAD vs XAD-Forge - Statistical comparison
  ##############################################################################
  compare:
    name: Compare XAD vs XAD-Forge
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Checkout QuantLib-Risks-Cpp-Forge
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake bc

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-compare
          max-size: 650M

      # --- Build QL + XAD (baseline) ---
      - name: Patch benchmark into original QuantLib-Risks-Cpp
        run: |
          cp QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/utilities_xad.hpp \
             QuantLib-Risks-Cpp/test-suite/

          cat >> QuantLib-Risks-Cpp/test-suite/CMakeLists.txt << 'EOF'

          # Standalone benchmark (patched from QuantLib-Risks-Cpp-Forge)
          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib (QL + XAD)
        run: |
          cd QuantLib
          cmake -B build-xad -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build (QL + XAD)
        run: |
          cd QuantLib/build-xad
          cmake --build . --target QuantLib-Risks_benchmark_standalone

      # --- Build QL + XAD-Forge ---
      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      - name: Configure QuantLib (QL + XAD-Forge)
        run: |
          cd QuantLib
          cmake -B build-forge -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp-Forge" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_TEST_SUITE=OFF \
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON \
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build (QL + XAD-Forge)
        run: |
          cd QuantLib/build-forge
          cmake --build .

      # --- Run benchmarks multiple times ---
      - name: Run Benchmark (QL + XAD)
        run: |
          set -e
          cd QuantLib/build-xad
          # warmup run
          ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone --quick
          rm -f benchmark_xad.log || true
          for i in $(seq 1 5) ; do \
            ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone | tee -a benchmark_xad.log ; \
          done

      - name: Run Benchmark (QL + XAD-Forge)
        run: |
          set -e
          cd QuantLib/build-forge
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          # warmup run
          ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone --quick
          rm -f benchmark_forge.log || true
          for i in $(seq 1 5) ; do \
            ./QuantLib-Risks-Cpp-Forge/test-suite/quantlib-risks-benchmark-standalone | tee -a benchmark_forge.log ; \
          done

      - name: Compare Results
        id: compare
        run: |
          set -e

          echo "## Benchmark Comparison: QL + XAD vs QL + XAD-Forge" > benchmark_results.md
          echo "" >> benchmark_results.md
          echo "Comparing original QuantLib-Risks-Cpp (XAD tape) vs Forge repo (JIT + JIT-AVX)." >> benchmark_results.md
          echo "" >> benchmark_results.md
          echo "- Commit: \`${{ github.sha }}\`" >> benchmark_results.md
          echo "- Runs: 5 (after warmup)" >> benchmark_results.md
          echo "" >> benchmark_results.md

          echo "### QL + XAD (Baseline)" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md
          tail -80 QuantLib/build-xad/benchmark_xad.log >> benchmark_results.md || echo "No log available" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md
          echo "" >> benchmark_results.md

          echo "### QL + XAD-Forge" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md
          tail -80 QuantLib/build-forge/benchmark_forge.log >> benchmark_results.md || echo "No log available" >> benchmark_results.md
          echo "\`\`\`" >> benchmark_results.md

          cat benchmark_results.md

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-compare
          path: benchmark_results.md

  ##############################################################################
  # Linux, double vs AReal vs JIT (no diff)
  # Compares plain double vs xad::AReal<double> vs Forge JIT on same hardware
  # This measures the overhead of the XAD type system and JIT execution
  ##############################################################################
  linux-type-overhead:
    name: Linux, double vs AReal vs JIT (no diff)
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/lballabio/quantlib-devenv:rolling

    steps:
      - name: Hardware Info
        run: |
          echo "===== CPU ====="
          lscpu | grep -E "^(Model name|CPU\(s\)|Thread|Core|Socket|CPU max MHz)"
          echo "===== Memory ====="
          free -h

      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Checkout Forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FORGE_REPO }}
          ref: ${{ env.FORGE_BRANCH }}
          path: forge

      - name: Checkout xad-forge
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_FORGE_REPO }}
          ref: ${{ env.XAD_FORGE_BRANCH }}
          path: xad-forge

      - name: Setup
        run: |
          apt-get update
          apt-get install -y ninja-build cmake

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.12
        with:
          key: linux-type-overhead
          max-size: 1G

      # =========================================================================
      # Build 1: QuantLib-Risks with Forge JIT (forward-only execution)
      # Built first to fail fast if there are issues with the new JIT benchmark
      # =========================================================================
      - name: Build Forge C API
        run: |
          cd forge
          cmake -B build -S api/c -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DFORGE_CAPI_BUILD_TESTS=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          cmake --build build
          cmake --install build

      - name: Create JIT forward-only benchmark
        run: |
          cat > QuantLib-Risks-Cpp/test-suite/benchmark_jit_forward.cpp << 'EOFCPP'
          /*
           * JIT forward-only benchmark using Forge (no derivatives computed)
           * Measures JIT kernel execution overhead vs plain double and AReal
           */
          #include <ql/quantlib.hpp>
          #include <XAD/XAD.hpp>
          #include <xad-forge/ForgeBackend.hpp>
          #include <chrono>
          #include <iostream>
          #include <iomanip>
          #include <vector>
          #include <numeric>
          #include <cmath>
          #include <algorithm>

          using namespace QuantLib;

          inline double value(double x) { return x; }
          template<class T> inline double value(const T& x) { return x.getValue(); }

          double computeMean(const std::vector<double>& v) {
              if (v.empty()) return 0.0;
              return std::accumulate(v.begin(), v.end(), 0.0) / v.size();
          }

          ext::shared_ptr<IborIndex> makeIndex(std::vector<Date> dates, const std::vector<Rate>& rates) {
              DayCounter dayCounter = Actual360();
              RelinkableHandle<YieldTermStructure> termStructure;
              ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));
              Date todaysDate = index->fixingCalendar().adjust(Date(4, September, 2005));
              Settings::instance().evaluationDate() = todaysDate;
              dates[0] = index->fixingCalendar().advance(todaysDate, index->fixingDays(), Days);
              termStructure.linkTo(ext::make_shared<ZeroCurve>(dates, rates, dayCounter));
              return index;
          }

          void runBenchmark(Size size, Size i_opt, Size j_opt, Size steps, int curveEndYears,
                            std::vector<std::pair<int, double>>& results) {
              using Clock = std::chrono::high_resolution_clock;
              using Duration = std::chrono::duration<double, std::milli>;

              Calendar calendar = TARGET();
              Date todaysDate(4, September, 2005);
              Settings::instance().evaluationDate() = todaysDate;
              Integer fixingDays = 2;
              Date settlementDate = calendar.adjust(calendar.advance(todaysDate, fixingDays, Days));
              DayCounter dayCounter = Actual360();

              // Same zero rates as double benchmark
              std::vector<Rate> baseZeroRates = {0.035, 0.0575};
              std::vector<Date> baseDates = {settlementDate, settlementDate + curveEndYears * Years};
              auto baseIndex = makeIndex(baseDates, baseZeroRates);

              ext::shared_ptr<LiborForwardModelProcess> process(
                  new LiborForwardModelProcess(size, baseIndex));
              process->setCovarParam(ext::make_shared<LfmCovarianceProxy>(
                  ext::make_shared<LmLinearExponentialVolatilityModel>(
                      process->fixingTimes(), 0.291, 1.483, 0.116, 0.00001),
                  ext::make_shared<LmExponentialCorrelationModel>(size, 0.5)));

              std::vector<Time> fixingTimes = process->fixingTimes();
              TimeGrid grid(fixingTimes.begin(), fixingTimes.end(), steps);

              std::vector<Size> location;
              for (Size idx = 0; idx < fixingTimes.size(); ++idx)
                  location.push_back(std::find(grid.begin(), grid.end(), fixingTimes[idx]) - grid.begin());

              Size numFactors = process->factors();
              Size exerciseStep = location[i_opt];
              Size fullGridSteps = grid.size() - 1;
              Size fullGridRandoms = fullGridSteps * numFactors;

              BusinessDayConvention convention = baseIndex->businessDayConvention();
              Date fwdStart = settlementDate + Period(6 * i_opt, Months);
              Date fwdMaturity = fwdStart + Period(6 * j_opt, Months);
              Schedule schedule(fwdStart, fwdMaturity, baseIndex->tenor(), calendar,
                                convention, convention, DateGeneration::Forward, false);

              std::vector<double> accrualStart(size), accrualEnd(size);
              for (Size k = 0; k < size; ++k) {
                  accrualStart[k] = value(process->accrualStartTimes()[k]);
                  accrualEnd[k] = value(process->accrualEndTimes()[k]);
              }

              std::vector<int> pathCounts = {10, 100, 1000, 10000, 100000};
              Size maxPaths = 100000;

              // Pre-generate random numbers
              std::cerr << "  Generating randoms..." << std::flush;
              typedef PseudoRandom::rsg_type rsg_type;
              rsg_type rsg = PseudoRandom::make_sequence_generator(fullGridRandoms, BigNatural(42));
              std::vector<std::vector<double>> allRandoms(maxPaths);
              for (Size n = 0; n < maxPaths; ++n) {
                  allRandoms[n].resize(fullGridRandoms);
                  const auto& seq = rsg.nextSequence();
                  for (Size m = 0; m < fullGridRandoms; ++m)
                      allRandoms[n][m] = value(seq.value[m]);
              }
              std::cerr << " Done." << std::endl;

              // Get swap rate and initial rates
              ext::shared_ptr<VanillaSwap> fwdSwap(
                  new VanillaSwap(Swap::Receiver, 1.0, schedule, 0.05, dayCounter,
                                  schedule, baseIndex, 0.0, baseIndex->dayCounter()));
              fwdSwap->setPricingEngine(ext::make_shared<DiscountingSwapEngine>(
                  baseIndex->forwardingTermStructure()));
              double swapRateVal = value(fwdSwap->fairRate());
              Array initRates = process->initialValues();

              size_t warmupIters = 2, benchIters = 5;

              for (size_t tc = 0; tc < pathCounts.size(); ++tc) {
                  Size nrTrails = pathCounts[tc];
                  std::vector<double> times;

                  for (size_t iter = 0; iter < warmupIters + benchIters; ++iter) {
                      auto t_start = Clock::now();

                      // Build JIT kernel (graph recording) - included in timing
                      auto forgeBackend = std::make_unique<xad::forge::ForgeBackend<double>>(false);
                      xad::JITCompiler<double> jit(std::move(forgeBackend));

                      std::vector<xad::AD> jit_initRates(size);
                      xad::AD jit_swapRate;
                      std::vector<xad::AD> jit_randoms(fullGridRandoms);

                      for (Size k = 0; k < size; ++k) {
                          jit_initRates[k] = xad::AD(value(initRates[k]));
                          jit.registerInput(jit_initRates[k]);
                      }
                      jit_swapRate = xad::AD(swapRateVal);
                      jit.registerInput(jit_swapRate);
                      for (Size m = 0; m < fullGridRandoms; ++m) {
                          jit_randoms[m] = xad::AD(0.0);
                          jit.registerInput(jit_randoms[m]);
                      }

                      jit.newRecording();

                      std::vector<xad::AD> asset_jit(size);
                      std::vector<xad::AD> assetAtExercise_jit(size);
                      for (Size k = 0; k < size; ++k) asset_jit[k] = jit_initRates[k];

                      for (Size step = 1; step <= fullGridSteps; ++step) {
                          Size offset = (step - 1) * numFactors;
                          Time t = grid[step - 1];
                          Time dt = grid.dt(step - 1);

                          Array dw(numFactors);
                          for (Size f = 0; f < numFactors; ++f)
                              dw[f] = jit_randoms[offset + f];

                          Array asset_arr(size);
                          for (Size k = 0; k < size; ++k) asset_arr[k] = asset_jit[k];

                          Array evolved = process->evolve(t, asset_arr, dt, dw);
                          for (Size k = 0; k < size; ++k) asset_jit[k] = evolved[k];

                          if (step == exerciseStep) {
                              for (Size k = 0; k < size; ++k)
                                  assetAtExercise_jit[k] = asset_jit[k];
                          }
                      }

                      std::vector<xad::AD> dis_jit(size);
                      xad::AD df_jit = xad::AD(1.0);
                      for (Size k = 0; k < size; ++k) {
                          double accrual = accrualEnd[k] - accrualStart[k];
                          df_jit = df_jit / (xad::AD(1.0) + assetAtExercise_jit[k] * accrual);
                          dis_jit[k] = df_jit;
                      }

                      xad::AD jit_npv = xad::AD(0.0);
                      for (Size m = i_opt; m < i_opt + j_opt; ++m) {
                          double accrual = accrualEnd[m] - accrualStart[m];
                          jit_npv = jit_npv + (jit_swapRate - assetAtExercise_jit[m]) * accrual * dis_jit[m];
                      }

                      xad::AD jit_payoff = xad::less(jit_npv, xad::AD(0.0)).If(xad::AD(0.0), jit_npv);
                      jit.registerOutput(jit_payoff);
                      jit.compile();

                      // MC execution
                      double mcPrice = 0.0;
                      for (Size n = 0; n < nrTrails; ++n) {
                          // Set inputs
                          for (Size k = 0; k < size; ++k)
                              xad::value(jit_initRates[k]) = value(initRates[k]);
                          xad::value(jit_swapRate) = swapRateVal;
                          for (Size m = 0; m < fullGridRandoms; ++m)
                              xad::value(jit_randoms[m]) = allRandoms[n][m];

                          // Forward only - no derivatives
                          double payoff_value;
                          jit.forward(&payoff_value);
                          mcPrice += payoff_value;
                      }
                      (void)mcPrice;

                      auto t_end = Clock::now();
                      if (iter >= warmupIters)
                          times.push_back(Duration(t_end - t_start).count());
                  }
                  results.push_back({pathCounts[tc], computeMean(times)});
              }
          }

          int main() {
              std::vector<std::pair<int, double>> smallResults, largeResults;

              std::cerr << "Running small swaption JIT benchmark..." << std::endl;
              runBenchmark(10, 2, 2, 8, 6, smallResults);

              std::cerr << "Running large swaption JIT benchmark..." << std::endl;
              runBenchmark(20, 10, 10, 20, 12, largeResults);

              // Output results in parseable format
              std::cout << "JIT_SMALL:";
              for (auto& r : smallResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              std::cout << "JIT_LARGE:";
              for (auto& r : largeResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              return 0;
          }
          EOFCPP

      - name: Add JIT benchmark target to QuantLib-Risks CMakeLists
        run: |
          cat >> QuantLib-Risks-Cpp/test-suite/CMakeLists.txt << 'EOF'

          # JIT forward-only benchmark for type overhead comparison
          add_executable(QuantLib-Risks_benchmark_jit benchmark_jit_forward.cpp)
          set_target_properties(QuantLib-Risks_benchmark_jit PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-jit")
          target_link_libraries(QuantLib-Risks_benchmark_jit PRIVATE
              ql_library
              QLRisks::forge
              ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib (xad-forge JIT)
        run: |
          cd QuantLib
          cmake -B build-jit -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=ON \
            -DCMAKE_PREFIX_PATH=$(pwd)/../install \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../xad-forge;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_ENABLE_FORGE=ON \
            -DQLRISKS_USE_FORGE_CAPI=ON \
            -DXAD_FORGE_USE_CAPI=ON \
            -DQLRISKS_BUILD_TEST_SUITE=OFF \
            -DQLRISKS_BUILD_BENCHMARK_STANDALONE=ON \
            -DQLRISKS_ENABLE_FORGE_TESTS=ON

      - name: Build QuantLib-Risks with JIT benchmark
        run: |
          cd QuantLib/build-jit
          cmake --build . --target QuantLib-Risks_benchmark_jit

      # =========================================================================
      # Build 2: QuantLib with plain double
      # =========================================================================
      - name: Create pricing-only benchmark for plain double
        run: |
          mkdir -p QuantLib/test-suite-double
          cat > QuantLib/test-suite-double/benchmark_double.cpp << 'EOFCPP'
          /*
           * Pricing-only benchmark using plain double (no XAD types)
           */
          #include <ql/quantlib.hpp>
          #include <chrono>
          #include <iostream>
          #include <iomanip>
          #include <vector>
          #include <numeric>
          #include <cmath>
          #include <algorithm>

          using namespace QuantLib;

          std::string getCpuInfo() {
          #ifdef __linux__
              FILE* fp = popen("grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2", "r");
              if (fp) {
                  char buf[256];
                  if (fgets(buf, sizeof(buf), fp)) {
                      pclose(fp);
                      std::string s(buf);
                      s.erase(0, s.find_first_not_of(" \t\n"));
                      s.erase(s.find_last_not_of(" \t\n") + 1);
                      return s;
                  }
                  pclose(fp);
              }
          #endif
              return "Unknown CPU";
          }

          double computeMean(const std::vector<double>& v) {
              if (v.empty()) return 0.0;
              return std::accumulate(v.begin(), v.end(), 0.0) / v.size();
          }

          double computeStddev(const std::vector<double>& v) {
              if (v.size() < 2) return 0.0;
              double mean = computeMean(v);
              double sq_sum = 0.0;
              for (auto x : v) sq_sum += (x - mean) * (x - mean);
              return std::sqrt(sq_sum / (v.size() - 1));
          }

          ext::shared_ptr<IborIndex> makeIndex(std::vector<Date> dates, const std::vector<Rate>& rates) {
              DayCounter dayCounter = Actual360();
              RelinkableHandle<YieldTermStructure> termStructure;
              ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));
              Date todaysDate = index->fixingCalendar().adjust(Date(4, September, 2005));
              Settings::instance().evaluationDate() = todaysDate;
              dates[0] = index->fixingCalendar().advance(todaysDate, index->fixingDays(), Days);
              termStructure.linkTo(ext::make_shared<ZeroCurve>(dates, rates, dayCounter));
              return index;
          }

          void runBenchmark(Size size, Size i_opt, Size j_opt, Size steps, int curveEndYears,
                            std::vector<std::pair<int, double>>& results) {
              using Clock = std::chrono::high_resolution_clock;
              using Duration = std::chrono::duration<double, std::milli>;

              Calendar calendar = TARGET();
              Date todaysDate(4, September, 2005);
              Settings::instance().evaluationDate() = todaysDate;
              Integer fixingDays = 2;
              Date settlementDate = calendar.adjust(calendar.advance(todaysDate, fixingDays, Days));
              DayCounter dayCounter = Actual360();

              std::vector<Rate> baseZeroRates = {0.035, 0.0575};
              std::vector<Date> baseDates = {settlementDate, settlementDate + curveEndYears * Years};
              auto baseIndex = makeIndex(baseDates, baseZeroRates);

              ext::shared_ptr<LiborForwardModelProcess> process(
                  new LiborForwardModelProcess(size, baseIndex));
              process->setCovarParam(ext::make_shared<LfmCovarianceProxy>(
                  ext::make_shared<LmLinearExponentialVolatilityModel>(
                      process->fixingTimes(), 0.291, 1.483, 0.116, 0.00001),
                  ext::make_shared<LmExponentialCorrelationModel>(size, 0.5)));

              std::vector<Time> fixingTimes = process->fixingTimes();
              TimeGrid grid(fixingTimes.begin(), fixingTimes.end(), steps);

              std::vector<Size> location;
              for (Size idx = 0; idx < fixingTimes.size(); ++idx)
                  location.push_back(std::find(grid.begin(), grid.end(), fixingTimes[idx]) - grid.begin());

              Size numFactors = process->factors();
              Size exerciseStep = location[i_opt];
              Size fullGridSteps = grid.size() - 1;
              Size fullGridRandoms = fullGridSteps * numFactors;

              BusinessDayConvention convention = baseIndex->businessDayConvention();
              Date fwdStart = settlementDate + Period(6 * i_opt, Months);
              Date fwdMaturity = fwdStart + Period(6 * j_opt, Months);
              Schedule schedule(fwdStart, fwdMaturity, baseIndex->tenor(), calendar,
                                convention, convention, DateGeneration::Forward, false);

              std::vector<double> accrualStart(size), accrualEnd(size);
              for (Size k = 0; k < size; ++k) {
                  accrualStart[k] = process->accrualStartTimes()[k];
                  accrualEnd[k] = process->accrualEndTimes()[k];
              }

              std::vector<int> pathCounts = {10, 100, 1000, 10000, 100000};
              Size maxPaths = 100000;

              std::cerr << "  Generating randoms..." << std::flush;
              typedef PseudoRandom::rsg_type rsg_type;
              rsg_type rsg = PseudoRandom::make_sequence_generator(fullGridRandoms, BigNatural(42));
              std::vector<std::vector<double>> allRandoms(maxPaths);
              for (Size n = 0; n < maxPaths; ++n) {
                  allRandoms[n].resize(fullGridRandoms);
                  const auto& seq = rsg.nextSequence();
                  for (Size m = 0; m < fullGridRandoms; ++m)
                      allRandoms[n][m] = seq.value[m];
              }
              std::cerr << " Done." << std::endl;

              ext::shared_ptr<VanillaSwap> fwdSwap(
                  new VanillaSwap(Swap::Receiver, 1.0, schedule, 0.05, dayCounter,
                                  schedule, baseIndex, 0.0, baseIndex->dayCounter()));
              fwdSwap->setPricingEngine(ext::make_shared<DiscountingSwapEngine>(
                  baseIndex->forwardingTermStructure()));
              double swapRate = fwdSwap->fairRate();
              Array initRates = process->initialValues();

              size_t warmupIters = 2, benchIters = 5;

              for (size_t tc = 0; tc < pathCounts.size(); ++tc) {
                  Size nrTrails = pathCounts[tc];
                  std::vector<double> times;

                  for (size_t iter = 0; iter < warmupIters + benchIters; ++iter) {
                      auto t_start = Clock::now();
                      double price = 0.0;
                      for (Size n = 0; n < nrTrails; ++n) {
                          Array asset(size);
                          for (Size k = 0; k < size; ++k) asset[k] = initRates[k];
                          Array assetAtExercise(size);
                          for (Size step = 1; step <= fullGridSteps; ++step) {
                              Size offset = (step - 1) * numFactors;
                              Array dw(numFactors);
                              for (Size f = 0; f < numFactors; ++f)
                                  dw[f] = allRandoms[n][offset + f];
                              asset = process->evolve(grid[step - 1], asset, grid.dt(step - 1), dw);
                              if (step == exerciseStep)
                                  for (Size k = 0; k < size; ++k) assetAtExercise[k] = asset[k];
                          }
                          Array dis(size);
                          double df = 1.0;
                          for (Size k = 0; k < size; ++k) {
                              df = df / (1.0 + assetAtExercise[k] * (accrualEnd[k] - accrualStart[k]));
                              dis[k] = df;
                          }
                          double npv = 0.0;
                          for (Size m = i_opt; m < i_opt + j_opt; ++m)
                              npv += (swapRate - assetAtExercise[m]) * (accrualEnd[m] - accrualStart[m]) * dis[m];
                          if (npv > 0.0) price += npv;
                      }
                      (void)price;
                      auto t_end = Clock::now();
                      if (iter >= warmupIters)
                          times.push_back(Duration(t_end - t_start).count());
                  }
                  results.push_back({pathCounts[tc], computeMean(times)});
              }
          }

          int main() {
              std::vector<std::pair<int, double>> smallResults, largeResults;

              std::cerr << "Running small swaption benchmark..." << std::endl;
              runBenchmark(10, 2, 2, 8, 6, smallResults);

              std::cerr << "Running large swaption benchmark..." << std::endl;
              runBenchmark(20, 10, 10, 20, 12, largeResults);

              // Output results in parseable format
              std::cout << "DOUBLE_SMALL:";
              for (auto& r : smallResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              std::cout << "DOUBLE_LARGE:";
              for (auto& r : largeResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              return 0;
          }
          EOFCPP

      - name: Add benchmark target to QuantLib CMakeLists
        run: |
          # Add standalone benchmark target to QuantLib's CMakeLists.txt
          cat >> QuantLib/CMakeLists.txt << 'EOF'

          # Plain double benchmark for type overhead comparison
          add_executable(benchmark_double test-suite-double/benchmark_double.cpp)
          target_link_libraries(benchmark_double PRIVATE ql_library ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib (plain double)
        run: |
          cd QuantLib
          cmake -B build-double -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF

      - name: Build QuantLib and benchmark (plain double)
        run: |
          cd QuantLib/build-double
          cmake --build . --target benchmark_double

      # =========================================================================
      # Build 3: QuantLib-Risks with xad::AReal<double>
      # =========================================================================
      - name: Patch benchmark into QuantLib-Risks-Cpp
        run: |
          cp QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp \
             QuantLib-Risks-Cpp/test-suite/
          cp QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp \
             QuantLib-Risks-Cpp/test-suite/

          cat >> QuantLib-Risks-Cpp/test-suite/CMakeLists.txt << 'EOF'

          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              ${QL_THREAD_LIBRARIES})
          EOF

      - name: Configure QuantLib (xad::AReal)
        run: |
          cd QuantLib
          cmake -B build-xad -G Ninja -DBOOST_ROOT=/usr \
            -DCMAKE_CXX_STANDARD=17 \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DXAD_WARNINGS_PARANOID=OFF \
            -DXAD_ENABLE_JIT=OFF \
            -DQL_EXTERNAL_SUBDIRECTORIES="$(pwd)/../xad;$(pwd)/../QuantLib-Risks-Cpp" \
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks \
            -DQL_NULL_AS_FUNCTIONS=ON \
            -DQL_BUILD_TEST_SUITE=OFF \
            -DQL_BUILD_EXAMPLES=OFF \
            -DQL_BUILD_BENCHMARK=OFF \
            -DQLRISKS_DISABLE_AAD=OFF \
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build QuantLib-Risks (xad::AReal)
        run: |
          cd QuantLib/build-xad
          cmake --build . --target QuantLib-Risks_benchmark_standalone

      # =========================================================================
      # Run all three benchmarks and compare
      # =========================================================================
      - name: Run Benchmarks
        run: |
          set -e

          echo "===== Running plain double benchmark ====="
          cd QuantLib/build-double
          ./benchmark_double > double_results.txt 2>&1
          cat double_results.txt

          echo ""
          echo "===== Running xad::AReal benchmark ====="
          cd ../build-xad
          ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-standalone --pricing-only > xad_results.txt 2>&1
          cat xad_results.txt

          echo ""
          echo "===== Running Forge JIT benchmark ====="
          cd ../build-jit
          export LD_LIBRARY_PATH=$(pwd)/../../install/lib:$LD_LIBRARY_PATH
          ./QuantLib-Risks-Cpp/test-suite/quantlib-risks-benchmark-jit > jit_results.txt 2>&1
          cat jit_results.txt

      - name: Generate Comparison Report
        run: |
          set -e
          cd QuantLib

          # Parse double results
          DOUBLE_SMALL=$(grep "^DOUBLE_SMALL:" build-double/double_results.txt | sed 's/DOUBLE_SMALL://')
          DOUBLE_LARGE=$(grep "^DOUBLE_LARGE:" build-double/double_results.txt | sed 's/DOUBLE_LARGE://')

          # Extract double timings (format: 10=0.0437;100=0.439;...)
          D_S_10=$(echo "$DOUBLE_SMALL" | grep -oP '10=\K[0-9.]+')
          D_S_100=$(echo "$DOUBLE_SMALL" | grep -oP '100=\K[0-9.]+')
          D_S_1K=$(echo "$DOUBLE_SMALL" | grep -oP '1000=\K[0-9.]+')
          D_S_10K=$(echo "$DOUBLE_SMALL" | grep -oP '10000=\K[0-9.]+')
          D_S_100K=$(echo "$DOUBLE_SMALL" | grep -oP '100000=\K[0-9.]+')

          D_L_10=$(echo "$DOUBLE_LARGE" | grep -oP '10=\K[0-9.]+')
          D_L_100=$(echo "$DOUBLE_LARGE" | grep -oP '100=\K[0-9.]+')
          D_L_1K=$(echo "$DOUBLE_LARGE" | grep -oP '1000=\K[0-9.]+')
          D_L_10K=$(echo "$DOUBLE_LARGE" | grep -oP '10000=\K[0-9.]+')
          D_L_100K=$(echo "$DOUBLE_LARGE" | grep -oP '100000=\K[0-9.]+')

          # Parse AReal results (extract Mean values from table lines like "|     10 |   Pricing |      0.1 |")
          # Get small swaption results (first set of results)
          AREAL_RESULTS=$(cat build-xad/xad_results.txt)

          # Extract pricing times from the output - look for lines with "Pricing" and extract the mean
          SMALL_SECTION=$(echo "$AREAL_RESULTS" | sed -n '/PRICING-ONLY: Small/,/PRICING-ONLY: Large/p')
          LARGE_SECTION=$(echo "$AREAL_RESULTS" | sed -n '/PRICING-ONLY: Large/,/All benchmarks complete/p')

          A_S_10=$(echo "$SMALL_SECTION" | grep -E "^\|[[:space:]]+10 \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_S_100=$(echo "$SMALL_SECTION" | grep -E "^\|[[:space:]]+100 \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_S_1K=$(echo "$SMALL_SECTION" | grep -E "^\|[[:space:]]+1K \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_S_10K=$(echo "$SMALL_SECTION" | grep -E "^\|[[:space:]]+10K \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_S_100K=$(echo "$SMALL_SECTION" | grep -E "^\|[[:space:]]+100K \|" | awk -F'|' '{print $4}' | tr -d ' ')

          A_L_10=$(echo "$LARGE_SECTION" | grep -E "^\|[[:space:]]+10 \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_L_100=$(echo "$LARGE_SECTION" | grep -E "^\|[[:space:]]+100 \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_L_1K=$(echo "$LARGE_SECTION" | grep -E "^\|[[:space:]]+1K \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_L_10K=$(echo "$LARGE_SECTION" | grep -E "^\|[[:space:]]+10K \|" | awk -F'|' '{print $4}' | tr -d ' ')
          A_L_100K=$(echo "$LARGE_SECTION" | grep -E "^\|[[:space:]]+100K \|" | awk -F'|' '{print $4}' | tr -d ' ')

          # Parse JIT results (format: 10=0.0437;100=0.439;...)
          JIT_SMALL=$(grep "^JIT_SMALL:" build-jit/jit_results.txt | sed 's/JIT_SMALL://')
          JIT_LARGE=$(grep "^JIT_LARGE:" build-jit/jit_results.txt | sed 's/JIT_LARGE://')

          J_S_10=$(echo "$JIT_SMALL" | grep -oP '10=\K[0-9.]+')
          J_S_100=$(echo "$JIT_SMALL" | grep -oP '100=\K[0-9.]+')
          J_S_1K=$(echo "$JIT_SMALL" | grep -oP '1000=\K[0-9.]+')
          J_S_10K=$(echo "$JIT_SMALL" | grep -oP '10000=\K[0-9.]+')
          J_S_100K=$(echo "$JIT_SMALL" | grep -oP '100000=\K[0-9.]+')

          J_L_10=$(echo "$JIT_LARGE" | grep -oP '10=\K[0-9.]+')
          J_L_100=$(echo "$JIT_LARGE" | grep -oP '100=\K[0-9.]+')
          J_L_1K=$(echo "$JIT_LARGE" | grep -oP '1000=\K[0-9.]+')
          J_L_10K=$(echo "$JIT_LARGE" | grep -oP '10000=\K[0-9.]+')
          J_L_100K=$(echo "$JIT_LARGE" | grep -oP '100000=\K[0-9.]+')

          echo "================================================================================"
          echo "  TYPE OVERHEAD COMPARISON: double vs xad::AReal<double> vs Forge JIT"
          echo "================================================================================"
          echo ""
          echo "This compares pricing-only performance (no derivatives) to measure"
          echo "the overhead of using xad::AReal<double> and Forge JIT instead of plain double."
          echo "All benchmarks ran on the same hardware in this job."
          echo ""
          echo "================================================================================"
          echo "  SMALL SWAPTION (1Y into 1Y)"
          echo "================================================================================"
          echo ""
          printf "| %6s | %12s | %12s | %12s | %12s | %12s |\n" "Paths" "double (ms)" "AReal (ms)" "JIT (ms)" "AReal OH" "JIT OH"
          printf "|%s|%s|%s|%s|%s|%s|\n" "-------:" "-------------:" "-------------:" "-------------:" "-------------:" "-------------:"

          for paths in "10 $D_S_10 $A_S_10 $J_S_10" "100 $D_S_100 $A_S_100 $J_S_100" "1K $D_S_1K $A_S_1K $J_S_1K" "10K $D_S_10K $A_S_10K $J_S_10K" "100K $D_S_100K $A_S_100K $J_S_100K"; do
            set -- $paths
            p=$1; d=$2; a=$3; j=$4
            if [ -n "$d" ] && [ -n "$a" ] && [ -n "$j" ] && [ "$d" != "0" ]; then
              areal_oh=$(awk "BEGIN {printf \"%.1f\", (($a - $d) / $d) * 100}")
              jit_oh=$(awk "BEGIN {printf \"%.1f\", (($j - $d) / $d) * 100}")
              printf "| %6s | %12.2f | %12.2f | %12.2f | %10s%% | %10s%% |\n" "$p" "$d" "$a" "$j" "$areal_oh" "$jit_oh"
            fi
          done

          echo ""
          echo "================================================================================"
          echo "  LARGE SWAPTION (5Y into 5Y)"
          echo "================================================================================"
          echo ""
          printf "| %6s | %12s | %12s | %12s | %12s | %12s |\n" "Paths" "double (ms)" "AReal (ms)" "JIT (ms)" "AReal OH" "JIT OH"
          printf "|%s|%s|%s|%s|%s|%s|\n" "-------:" "-------------:" "-------------:" "-------------:" "-------------:" "-------------:"

          for paths in "10 $D_L_10 $A_L_10 $J_L_10" "100 $D_L_100 $A_L_100 $J_L_100" "1K $D_L_1K $A_L_1K $J_L_1K" "10K $D_L_10K $A_L_10K $J_L_10K" "100K $D_L_100K $A_L_100K $J_L_100K"; do
            set -- $paths
            p=$1; d=$2; a=$3; j=$4
            if [ -n "$d" ] && [ -n "$a" ] && [ -n "$j" ] && [ "$d" != "0" ]; then
              areal_oh=$(awk "BEGIN {printf \"%.1f\", (($a - $d) / $d) * 100}")
              jit_oh=$(awk "BEGIN {printf \"%.1f\", (($j - $d) / $d) * 100}")
              printf "| %6s | %12.2f | %12.2f | %12.2f | %10s%% | %10s%% |\n" "$p" "$d" "$a" "$j" "$areal_oh" "$jit_oh"
            fi
          done

          echo ""
          echo "================================================================================"
          echo "  SUMMARY"
          echo "================================================================================"
          echo ""
          echo "Overhead (OH) represents the cost relative to plain double:"
          echo "  - AReal OH: Cost of using xad::AReal<double> in passive mode (no tape recording)"
          echo "  - JIT OH: Cost of Forge JIT (graph recording + compilation + forward execution)"
          echo ""
          echo "Note: JIT timing includes kernel compilation, which is a fixed cost that"
          echo "      amortizes over more paths. This matches the AD benchmark methodology."
          echo ""

  ##############################################################################
  # Windows, double vs AReal (no diff)
  # Compares plain double vs xad::AReal<double> on same hardware
  # This measures the overhead of the XAD type system in passive mode
  ##############################################################################
  windows-type-overhead:
    name: Windows, double vs AReal (no diff)
    runs-on: windows-2022

    env:
      VSVARSALL: C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat

    steps:
      - name: Checkout QuantLib
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QL_REPO }}
          ref: ${{ env.QL_BRANCH }}
          path: QuantLib

      - name: Checkout XAD
        uses: actions/checkout@v4
        with:
          repository: ${{ env.XAD_REPO }}
          ref: ${{ env.XAD_BRANCH }}
          path: xad

      - name: Checkout QuantLib-Risks-Cpp (Original)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.QLRISKS_REPO }}
          ref: ${{ env.QLRISKS_BRANCH }}
          path: QuantLib-Risks-Cpp

      - name: Checkout QuantLib-Risks-Cpp-Forge (for benchmark code)
        uses: actions/checkout@v4
        with:
          path: QuantLib-Risks-Cpp-Forge

      - name: Setup
        run: choco install -y ninja

      - name: Setup Boost
        run: |
          $Url = "https://downloads.sourceforge.net/project/boost/boost-binaries/1.86.0/boost_1_86_0-msvc-14.3-64.exe"
          (New-Object System.Net.WebClient).DownloadFile($Url, "$RUNNER_TEMP\boost.exe")
          Start-Process -Wait -FilePath "$RUNNER_TEMP\boost.exe" "/SILENT","/SP-","/SUPPRESSMSGBOXES","/DIR=C:\local\boost"
          echo "BOOST_ROOT=C:\local\boost" >> $env:GITHUB_ENV

      # =========================================================================
      # Build 1: QuantLib with plain double
      # =========================================================================
      - name: Create pricing-only benchmark for plain double
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "QuantLib/test-suite-double"
          @'
          /*
           * Pricing-only benchmark using plain double (no XAD types)
           */
          #include <ql/quantlib.hpp>
          #include <chrono>
          #include <iostream>
          #include <iomanip>
          #include <vector>
          #include <numeric>
          #include <cmath>
          #include <algorithm>

          using namespace QuantLib;

          double computeMean(const std::vector<double>& v) {
              if (v.empty()) return 0.0;
              return std::accumulate(v.begin(), v.end(), 0.0) / v.size();
          }

          double computeStddev(const std::vector<double>& v) {
              if (v.size() < 2) return 0.0;
              double mean = computeMean(v);
              double sq_sum = 0.0;
              for (auto x : v) sq_sum += (x - mean) * (x - mean);
              return std::sqrt(sq_sum / (v.size() - 1));
          }

          ext::shared_ptr<IborIndex> makeIndex(std::vector<Date> dates, const std::vector<Rate>& rates) {
              DayCounter dayCounter = Actual360();
              RelinkableHandle<YieldTermStructure> termStructure;
              ext::shared_ptr<IborIndex> index(new Euribor6M(termStructure));
              Date todaysDate = index->fixingCalendar().adjust(Date(4, September, 2005));
              Settings::instance().evaluationDate() = todaysDate;
              dates[0] = index->fixingCalendar().advance(todaysDate, index->fixingDays(), Days);
              termStructure.linkTo(ext::make_shared<ZeroCurve>(dates, rates, dayCounter));
              return index;
          }

          void runBenchmark(Size size, Size i_opt, Size j_opt, Size steps, int curveEndYears,
                            std::vector<std::pair<int, double>>& results) {
              using Clock = std::chrono::high_resolution_clock;
              using Duration = std::chrono::duration<double, std::milli>;

              Calendar calendar = TARGET();
              Date todaysDate(4, September, 2005);
              Settings::instance().evaluationDate() = todaysDate;
              Integer fixingDays = 2;
              Date settlementDate = calendar.adjust(calendar.advance(todaysDate, fixingDays, Days));
              DayCounter dayCounter = Actual360();

              std::vector<Rate> baseZeroRates = {0.035, 0.0575};
              std::vector<Date> baseDates = {settlementDate, settlementDate + curveEndYears * Years};
              auto baseIndex = makeIndex(baseDates, baseZeroRates);

              ext::shared_ptr<LiborForwardModelProcess> process(
                  new LiborForwardModelProcess(size, baseIndex));
              process->setCovarParam(ext::make_shared<LfmCovarianceProxy>(
                  ext::make_shared<LmLinearExponentialVolatilityModel>(
                      process->fixingTimes(), 0.291, 1.483, 0.116, 0.00001),
                  ext::make_shared<LmExponentialCorrelationModel>(size, 0.5)));

              std::vector<Time> fixingTimes = process->fixingTimes();
              TimeGrid grid(fixingTimes.begin(), fixingTimes.end(), steps);

              std::vector<Size> location;
              for (Size idx = 0; idx < fixingTimes.size(); ++idx)
                  location.push_back(std::find(grid.begin(), grid.end(), fixingTimes[idx]) - grid.begin());

              Size numFactors = process->factors();
              Size exerciseStep = location[i_opt];
              Size fullGridSteps = grid.size() - 1;
              Size fullGridRandoms = fullGridSteps * numFactors;

              BusinessDayConvention convention = baseIndex->businessDayConvention();
              Date fwdStart = settlementDate + Period(6 * i_opt, Months);
              Date fwdMaturity = fwdStart + Period(6 * j_opt, Months);
              Schedule schedule(fwdStart, fwdMaturity, baseIndex->tenor(), calendar,
                                convention, convention, DateGeneration::Forward, false);

              std::vector<double> accrualStart(size), accrualEnd(size);
              for (Size k = 0; k < size; ++k) {
                  accrualStart[k] = process->accrualStartTimes()[k];
                  accrualEnd[k] = process->accrualEndTimes()[k];
              }

              std::vector<int> pathCounts = {10, 100, 1000, 10000, 100000};
              Size maxPaths = 100000;

              std::cerr << "  Generating randoms..." << std::flush;
              typedef PseudoRandom::rsg_type rsg_type;
              rsg_type rsg = PseudoRandom::make_sequence_generator(fullGridRandoms, BigNatural(42));
              std::vector<std::vector<double>> allRandoms(maxPaths);
              for (Size n = 0; n < maxPaths; ++n) {
                  allRandoms[n].resize(fullGridRandoms);
                  const auto& seq = rsg.nextSequence();
                  for (Size m = 0; m < fullGridRandoms; ++m)
                      allRandoms[n][m] = seq.value[m];
              }
              std::cerr << " Done." << std::endl;

              ext::shared_ptr<VanillaSwap> fwdSwap(
                  new VanillaSwap(Swap::Receiver, 1.0, schedule, 0.05, dayCounter,
                                  schedule, baseIndex, 0.0, baseIndex->dayCounter()));
              fwdSwap->setPricingEngine(ext::make_shared<DiscountingSwapEngine>(
                  baseIndex->forwardingTermStructure()));
              double swapRate = fwdSwap->fairRate();
              Array initRates = process->initialValues();

              size_t warmupIters = 2, benchIters = 5;

              for (size_t tc = 0; tc < pathCounts.size(); ++tc) {
                  Size nrTrails = pathCounts[tc];
                  std::vector<double> times;

                  for (size_t iter = 0; iter < warmupIters + benchIters; ++iter) {
                      auto t_start = Clock::now();
                      double price = 0.0;
                      for (Size n = 0; n < nrTrails; ++n) {
                          Array asset(size);
                          for (Size k = 0; k < size; ++k) asset[k] = initRates[k];
                          Array assetAtExercise(size);
                          for (Size step = 1; step <= fullGridSteps; ++step) {
                              Size offset = (step - 1) * numFactors;
                              Array dw(numFactors);
                              for (Size f = 0; f < numFactors; ++f)
                                  dw[f] = allRandoms[n][offset + f];
                              asset = process->evolve(grid[step - 1], asset, grid.dt(step - 1), dw);
                              if (step == exerciseStep)
                                  for (Size k = 0; k < size; ++k) assetAtExercise[k] = asset[k];
                          }
                          Array dis(size);
                          double df = 1.0;
                          for (Size k = 0; k < size; ++k) {
                              df = df / (1.0 + assetAtExercise[k] * (accrualEnd[k] - accrualStart[k]));
                              dis[k] = df;
                          }
                          double npv = 0.0;
                          for (Size m = i_opt; m < i_opt + j_opt; ++m)
                              npv += (swapRate - assetAtExercise[m]) * (accrualEnd[m] - accrualStart[m]) * dis[m];
                          if (npv > 0.0) price += npv;
                      }
                      (void)price;
                      auto t_end = Clock::now();
                      if (iter >= warmupIters)
                          times.push_back(Duration(t_end - t_start).count());
                  }
                  results.push_back({pathCounts[tc], computeMean(times)});
              }
          }

          int main() {
              std::vector<std::pair<int, double>> smallResults, largeResults;

              std::cerr << "Running small swaption benchmark..." << std::endl;
              runBenchmark(10, 2, 2, 8, 6, smallResults);

              std::cerr << "Running large swaption benchmark..." << std::endl;
              runBenchmark(20, 10, 10, 20, 12, largeResults);

              std::cout << "DOUBLE_SMALL:";
              for (auto& r : smallResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              std::cout << "DOUBLE_LARGE:";
              for (auto& r : largeResults) std::cout << r.first << "=" << r.second << ";";
              std::cout << std::endl;

              return 0;
          }
          '@ | Out-File -FilePath "QuantLib/test-suite-double/benchmark_double.cpp" -Encoding utf8

      - name: Add benchmark target to QuantLib CMakeLists
        shell: pwsh
        run: |
          # Add standalone benchmark target to QuantLib's CMakeLists.txt
          $cmakeAddition = @"

          # Plain double benchmark for type overhead comparison
          add_executable(benchmark_double test-suite-double/benchmark_double.cpp)
          target_link_libraries(benchmark_double PRIVATE ql_library `${QL_THREAD_LIBRARIES})
          "@
          Add-Content -Path "QuantLib/CMakeLists.txt" -Value $cmakeAddition

      - name: Configure QuantLib (plain double)
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build-double -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF

      - name: Build QuantLib and benchmark (plain double)
        shell: cmd
        run: |
          cd QuantLib\build-double
          call "%VSVARSALL%" amd64
          cmake --build . --target benchmark_double --config Release

      # =========================================================================
      # Build 2: QuantLib-Risks with xad::AReal<double>
      # =========================================================================
      - name: Patch benchmark into QuantLib-Risks-Cpp
        shell: pwsh
        run: |
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/benchmark_main.cpp" "QuantLib-Risks-Cpp/test-suite/"
          Copy-Item "QuantLib-Risks-Cpp-Forge/test-suite/PlatformInfo.hpp" "QuantLib-Risks-Cpp/test-suite/"

          $cmakeAddition = @"

          add_executable(QuantLib-Risks_benchmark_standalone benchmark_main.cpp)
          set_target_properties(QuantLib-Risks_benchmark_standalone PROPERTIES
              OUTPUT_NAME "quantlib-risks-benchmark-standalone")
          target_link_libraries(QuantLib-Risks_benchmark_standalone PRIVATE
              ql_library
              `${QL_THREAD_LIBRARIES})
          "@
          Add-Content -Path "QuantLib-Risks-Cpp/test-suite/CMakeLists.txt" -Value $cmakeAddition

      - name: Configure QuantLib (xad::AReal)
        shell: cmd
        run: |
          cd QuantLib
          call "%VSVARSALL%" amd64
          cmake -B build-xad -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_CXX_STANDARD=17 ^
            -DXAD_WARNINGS_PARANOID=OFF ^
            -DXAD_ENABLE_JIT=OFF ^
            -DXAD_STATIC_MSVC_RUNTIME=ON ^
            -DQL_EXTERNAL_SUBDIRECTORIES="%cd%\..\xad;%cd%\..\QuantLib-Risks-Cpp" ^
            -DQL_EXTRA_LINK_LIBRARIES=QuantLib-Risks ^
            -DQL_NULL_AS_FUNCTIONS=ON ^
            -DQL_BUILD_TEST_SUITE=OFF ^
            -DQL_BUILD_EXAMPLES=OFF ^
            -DQL_BUILD_BENCHMARK=OFF ^
            -DQLRISKS_DISABLE_AAD=OFF ^
            -DQLRISKS_BUILD_TEST_SUITE=ON

      - name: Build QuantLib-Risks (xad::AReal)
        shell: cmd
        run: |
          cd QuantLib\build-xad
          call "%VSVARSALL%" amd64
          cmake --build . --target QuantLib-Risks_benchmark_standalone --config Release

      # =========================================================================
      # Run both benchmarks and compare
      # =========================================================================
      - name: Run Benchmarks
        shell: cmd
        run: |
          echo ===== Running plain double benchmark =====
          cd QuantLib\build-double
          benchmark_double.exe > double_results.txt 2>&1
          type double_results.txt

          echo.
          echo ===== Running xad::AReal benchmark =====
          cd ..\build-xad
          QuantLib-Risks-Cpp\test-suite\quantlib-risks-benchmark-standalone.exe --pricing-only > xad_results.txt 2>&1
          type xad_results.txt

      - name: Generate Comparison Report
        shell: pwsh
        run: |
          # Parse double results
          $doubleContent = Get-Content "QuantLib/build-double/double_results.txt" -Raw
          $doubleSmall = ($doubleContent | Select-String "DOUBLE_SMALL:(.+)").Matches[0].Groups[1].Value
          $doubleLarge = ($doubleContent | Select-String "DOUBLE_LARGE:(.+)").Matches[0].Groups[1].Value

          # Extract double timings
          function Parse-DoubleResults($line) {
            $results = @{}
            $line -split ';' | Where-Object { $_ -match '(\d+)=([0-9.]+)' } | ForEach-Object {
              $_ -match '(\d+)=([0-9.]+)' | Out-Null
              $results[$Matches[1]] = [double]$Matches[2]
            }
            return $results
          }

          $dSmall = Parse-DoubleResults $doubleSmall
          $dLarge = Parse-DoubleResults $doubleLarge

          # Parse AReal results
          $xadContent = Get-Content "QuantLib/build-xad/xad_results.txt" -Raw

          function Parse-XadResults($content, $section) {
            $results = @{}
            $inSection = $false
            $content -split "`n" | ForEach-Object {
              if ($_ -match "PRICING-ONLY: $section") { $inSection = $true }
              elseif ($_ -match "PRICING-ONLY:" -and $inSection) { $inSection = $false }
              elseif ($inSection -and $_ -match '^\|\s+(\d+K?)\s+\|\s+Pricing\s+\|\s+([0-9.]+)') {
                $paths = $Matches[1]
                $time = [double]$Matches[2]
                # Convert path label to number
                $pathNum = if ($paths -match '(\d+)K') { [int]$Matches[1] * 1000 } else { [int]$paths }
                $results["$pathNum"] = $time
              }
            }
            return $results
          }

          $aSmall = Parse-XadResults $xadContent "Small"
          $aLarge = Parse-XadResults $xadContent "Large"

          Write-Host "================================================================================"
          Write-Host "  TYPE OVERHEAD COMPARISON: double vs xad::AReal<double>"
          Write-Host "================================================================================"
          Write-Host ""
          Write-Host "This compares pricing-only performance (no derivatives) to measure"
          Write-Host "the overhead of using xad::AReal<double> instead of plain double."
          Write-Host "Both benchmarks ran on the same hardware in this job."
          Write-Host ""
          Write-Host "================================================================================"
          Write-Host "  SMALL SWAPTION (1Y into 1Y)"
          Write-Host "================================================================================"
          Write-Host ""
          Write-Host ("| {0,6} | {1,12} | {2,12} | {3,10} |" -f "Paths", "double (ms)", "AReal (ms)", "Overhead")
          Write-Host "|-------:|-------------:|-------------:|-----------:|"

          @("10", "100", "1000", "10000", "100000") | ForEach-Object {
            $p = $_
            $label = if ([int]$p -ge 1000) { "{0}K" -f ([int]$p / 1000) } else { $p }
            if ($dSmall[$p] -and $aSmall[$p]) {
              $d = $dSmall[$p]
              $a = $aSmall[$p]
              $overhead = (($a - $d) / $d) * 100
              Write-Host ("| {0,6} | {1,12:F2} | {2,12:F1} | {3,9:F1}% |" -f $label, $d, $a, $overhead)
            }
          }

          Write-Host ""
          Write-Host "================================================================================"
          Write-Host "  LARGE SWAPTION (5Y into 5Y)"
          Write-Host "================================================================================"
          Write-Host ""
          Write-Host ("| {0,6} | {1,12} | {2,12} | {3,10} |" -f "Paths", "double (ms)", "AReal (ms)", "Overhead")
          Write-Host "|-------:|-------------:|-------------:|-----------:|"

          @("10", "100", "1000", "10000", "100000") | ForEach-Object {
            $p = $_
            $label = if ([int]$p -ge 1000) { "{0}K" -f ([int]$p / 1000) } else { $p }
            if ($dLarge[$p] -and $aLarge[$p]) {
              $d = $dLarge[$p]
              $a = $aLarge[$p]
              $overhead = (($a - $d) / $d) * 100
              Write-Host ("| {0,6} | {1,12:F2} | {2,12:F1} | {3,9:F1}% |" -f $label, $d, $a, $overhead)
            }
          }

          Write-Host ""
          Write-Host "================================================================================"
          Write-Host "  SUMMARY"
          Write-Host "================================================================================"
          Write-Host ""
          Write-Host "Overhead represents the cost of using xad::AReal<double> instead of plain double,"
          Write-Host "even when not computing derivatives (passive mode, no tape recording)."
          Write-Host ""
